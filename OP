-- Pet Warriors - Optimized

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

local requestFunc = (syn and syn.request) or (http and http.request) or request
if not requestFunc then
    warn("Your executor does not support HTTP requests.")
    return
end

local player = Players.LocalPlayer
local userid = player.UserId
local username = player.Name



local Library = loadstring(game:HttpGet("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()

local Window = Library:Window{
    Title = "Pet Warriors",
    SubTitle = "by Ducky",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Resize = false,
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}

-- Services and Controllers (defined once)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Function to click top-right
local function clickTopRight()
    local screenSize = workspace.CurrentCamera.ViewportSize
    local x = screenSize.X - 5  -- slightly inside from the right edge
    local y = 5                 -- slightly down from the top

    -- Mouse down + mouse up
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)

    print("[AutoClick] Clicked at top-right:", x, y)
end



local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
if not Knit.Started then
    Knit.OnStart():await()
end

-- Common Controllers and Services
local BreakableController = require(LocalPlayer.PlayerScripts.Client.Controllers.Normal.Breakables.BreakableController)
local WorldController = Knit.GetController("WorldController")
local ZoneController = Knit.GetController("ZoneController")
local DataController = Knit.GetController("DataController")
local BackpackController = Knit.GetController("BackpackController")

-- Enums (loaded once)
local BreakablesEnum = require(ReplicatedStorage.Shared.Enums.Breakables)
local ItemTiersEnum = require(ReplicatedStorage.Shared.Enums.ItemTiers)
local BackpackCategory = require(ReplicatedStorage.Shared.Enums.BackpackCategory)
local BackpackCurrencyTypes = require(ReplicatedStorage.Shared.Enums.BackpackCurrencyTypes)
local VendingMachines = require(ReplicatedStorage.Shared.Balancing.Shared.VendingMachines)

-- Services (loaded once)
local EggService = ReplicatedStorage.Shared.Packages.Knit.Services.EggService
local SwordCrateService = ReplicatedStorage.Shared.Packages.Knit.Services.SwordCrateService
local BattleService = ReplicatedStorage.Shared.Packages.Knit.Services.BattleService
local UpgradeTreeService = ReplicatedStorage.Shared.Packages.Knit.Services.UpgradeTreeService
local GoldMachineService = ReplicatedStorage.Shared.Packages.Knit.Services.GoldMachineService
local PlotService = ReplicatedStorage.Shared.Packages.Knit.Services.PlotService
local PlantService = ReplicatedStorage.Shared.Packages.Knit.Services.PlantService

-- Tabs
local Tabs = {
    Player = Window:AddTab({ Title = "Player Settings", Icon = "person-standing" }),
    AutoFarm = Window:AddTab({ Title = "Main", Icon = "sword" }),
    Eggs = Window:AddTab({ Title = "Hatch", Icon = "egg" }),
    Upgrades = Window:AddTab({ Title = "Upgrades", Icon = "star" }),
    Machines = Window:AddTab({ Title = "Machines", Icon = "cog" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "rocket" }),
    Plant = Window:AddTab({ Title = "Gardening", Icon = "phosphor-plant-bold" }),
    Potion = Window:AddTab({ Title = "Potion Crafting", Icon = "flask-conical" }),
    Enchant = Window:AddTab({ Title = "Enchant Upgrades", Icon = "book-open" }),
    Minigames = Window:AddTab({ Title = "Minigames", Icon = "phosphor-game-controller-light" }),
    Gifts = Window:AddTab({ Title = "Misc", Icon = "gift" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

-- Optional AFK Module
local AFKModule
pcall(function()
    AFKModule = require(ReplicatedStorage.Shared.Vendor.AFKModule)
end)

PlayerSettings = Tabs.Player:AddSection("Player Settings")

local walkSpeedValue = 16
local jumpPowerValue = 50
local noclipEnabled = false
local noclipConnection = nil

-- Apply saved WalkSpeed and JumpPower to the character
local function applyCharacterSettings(character)
    local humanoid = character:WaitForChild("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = walkSpeedValue or 16
        humanoid.JumpPower = jumpPowerValue or 50
    end
end

-- Apply on current character
if LocalPlayer.Character then
    applyCharacterSettings(LocalPlayer.Character)
end

-- Reapply on respawn
LocalPlayer.CharacterAdded:Connect(function(character)
    applyCharacterSettings(character)
end)

-- Update your existing input callbacks to only update the saved values
PlayerSettings:AddInput("SetWalkSpeed", {
    Title = "Set WalkSpeed",
    Description = "Set your WalkSpeed (16 is default)",
    Placeholder = "16",
    Numeric = true,
    Default = "16",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            walkSpeedValue = num
        else
            walkSpeedValue = 16
        end
        -- Apply immediately if character exists
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = walkSpeedValue
            end
        end
    end
})

PlayerSettings:AddInput("SetJumpPower", {
    Title = "Set JumpPower",
    Description = "Set your JumpPower (50 is default)",
    Placeholder = "50",
    Numeric = true,
    Default = "50",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            jumpPowerValue = num
        else
            jumpPowerValue = 50
        end
        -- Apply immediately if character exists
        if LocalPlayer.Character then
            local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.JumpPower = jumpPowerValue
            end
        end
    end
})

PlayerSettings:AddToggle("NoclipToggle", {
    Title = "Noclip",
    Description = "Walk through walls and objects.",
    Default = false,
    Callback = function(enabled)
        noclipEnabled = enabled
        if noclipEnabled then
            noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                local character = LocalPlayer.Character
                if character then
                    for _, part in ipairs(character:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
            -- Restore CanCollide when disabling
            local character = LocalPlayer.Character
            if character then
                for _, part in ipairs(character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
})

local infiniteJumpEnabled = false
PlayerSettings:AddToggle("InfiniteJumpToggle", {
    Title = "Infinite Jump",
    Description = "Allows you to jump repeatedly in mid-air.",
    Default = false,
    Callback = function(enabled)
        infiniteJumpEnabled = enabled
    end
})

game:GetService("UserInputService").JumpRequest:Connect(function()
    if infiniteJumpEnabled then
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end
end)

-- Fly
local flyEnabled = false
local flyConnection = nil
PlayerSettings:AddToggle("FlyToggle", {
    Title = "Fly",
    Description = "Fly freely using WASD + Space/Shift. Speed matches WalkSpeed.",
    Default = false,
    Callback = function(enabled)
        flyEnabled = enabled
        local character = LocalPlayer.Character
        if character then
            local root = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if root and humanoid then
                if enabled then
                    humanoid.PlatformStand = true
                    local velocity = Instance.new("BodyVelocity")
                    velocity.MaxForce = Vector3.new(1e5,1e5,1e5)
                    velocity.Velocity = Vector3.new(0,0,0)
                    velocity.Name = "FlyVelocity"
                    velocity.Parent = root

                    flyConnection = game:GetService("RunService").RenderStepped:Connect(function()
                        local move = Vector3.new()
                        local UserInputService = game:GetService("UserInputService")
                        local cam = workspace.CurrentCamera

                        if UserInputService:IsKeyDown(Enum.KeyCode.W) then move = move + cam.CFrame.LookVector end
                        if UserInputService:IsKeyDown(Enum.KeyCode.S) then move = move - cam.CFrame.LookVector end
                        if UserInputService:IsKeyDown(Enum.KeyCode.A) then move = move - cam.CFrame.RightVector end
                        if UserInputService:IsKeyDown(Enum.KeyCode.D) then move = move + cam.CFrame.RightVector end
                        if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move = move + Vector3.new(0,1,0) end
                        if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then move = move - Vector3.new(0,1,0) end

                        if move.Magnitude > 0 then
                            velocity.Velocity = move.Unit * humanoid.WalkSpeed
                        else
                            velocity.Velocity = Vector3.new(0,0,0)
                        end
                    end)
                else
                    if flyConnection then flyConnection:Disconnect() flyConnection = nil end
                    local flyVel = root:FindFirstChild("FlyVelocity")
                    if flyVel then flyVel:Destroy() end
                    humanoid.PlatformStand = false
                end
            end
        end
    end
})


local teleportEnabled = false
local teleportConnection = nil

PlayerSettings:AddToggle("TeleportToggle", {
    Title = "Teleport",
    Description = "Right click and jump to teleport where your mouse is hovering. Some objects are invisible, so don't worry if you teleport to something you can't see.",
    Default = false,
    Callback = function(enabled)
        teleportEnabled = enabled

        if enabled then
            teleportConnection = task.spawn(function()
                local Players = game:GetService("Players")
                local UserInputService = game:GetService("UserInputService")
                local player = Players.LocalPlayer

                local rightClickDown = false

                UserInputService.InputBegan:Connect(function(input, gameProcessed)
                    if gameProcessed then return end
                    if input.UserInputType == Enum.UserInputType.MouseButton2 then
                        rightClickDown = true
                    end
                end)

                UserInputService.InputEnded:Connect(function(input)
                    if input.UserInputType == Enum.UserInputType.MouseButton2 then
                        rightClickDown = false
                    end
                end)

                while teleportEnabled do
                    local character = player.Character or player.CharacterAdded:Wait()
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    local root = character:FindFirstChild("HumanoidRootPart")
                    local mouse = player:GetMouse()

                    if humanoid and root then
                        humanoid.Jumping:Connect(function()
                            if teleportEnabled and rightClickDown then
                                local target = mouse.Target
                                if target and target:IsDescendantOf(workspace) then
                                    local targetPos = mouse.Hit.Position
                                    root.CFrame = CFrame.new(targetPos + Vector3.new(0, 1, 0))
                                end
                            end
                        end)
                    end

                    player.CharacterAdded:Wait()
                end
            end)
        else
            if teleportConnection then
                task.cancel(teleportConnection)
                teleportConnection = nil
            end
        end
    end
})

PlayerSettings:AddButton({
    Title = "Respawn",
    Description = "Respawn incase your stuck.",
    Callback = function()
        local character = LocalPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = 0
            end
        end
    end
})



-- === AUTO TRAIN SECTION ===
AutoCollectSection = Tabs.AutoFarm:AddSection("Auto Train")

-- Collect breakable names for dropdown, exclude hearts with sizes
local breakableNames = {}
local uniqueItems = {}

local function getSuffixName(enumName)
    -- Remove W#_Z#_ prefix (e.g., W1_Z2_egg -> egg)
    local suffix = enumName:match("^W%d+_Z%d+_(.+)$") or enumName
    return suffix
end

for enumName, enumId in pairs(BreakablesEnum) do
    local name = getSuffixName(enumName):upper()

    -- Keep only the heart size segment if present
    if name:match("_LARGE_HEARTS$") then
        name = "LARGE_HEARTS"
    elseif name:match("_MEDIUM_HEARTS$") then
        name = "MEDIUM_HEARTS"
    elseif name:match("_SMALL_HEARTS$") then
        name = "SMALL_HEARTS"
    end

    -- Store only unique names
    if not uniqueItems[name] then
        uniqueItems[name] = enumId
        table.insert(breakableNames, name)
    end
end



table.sort(breakableNames)

-- UI Paragraph to show priority list
local breakablePriorityParagraph = AutoCollectSection:AddParagraph("BreakablePriority", {
    Title = "Target Priority",
    Content = "No breakables selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Breakable priorities storage: name -> priority (lower = higher priority)
local breakablePriorities = {}
local nextPriority = 1

local function updateBreakablePriorityDisplay()
    local prioritized = {}
    for name, priority in pairs(breakablePriorities) do
        table.insert(prioritized, {name = name, priority = priority})
    end
    table.sort(prioritized, function(a,b) return a.priority < b.priority end)

    if #prioritized == 0 then
        breakablePriorityParagraph:SetValue("No breakables selected")
        return
    end

    local text = "Priority order:\n"
    for i, item in ipairs(prioritized) do
        text = text .. i .. ". " .. item.name .. "\n"
    end
    breakablePriorityParagraph:SetValue(text)
end


-- Then your dropdown uses breakableNames without prefixes
breakableDropdown = AutoCollectSection:AddDropdown("BreakableSelect", {
    Title = "Select what to aim for",
    Description = "Items will be prioritized in the order selected. First = highest priority.",
    Values = breakableNames,
    Multi = true,
    Searchable = true,
    Default = {},
    Callback = function(value)
        -- Track selected breakables as suffix names
        local currentlySelected = {}
        for name, selected in pairs(value) do
            if selected then
                currentlySelected[name] = true
            end
        end

        -- Remove deselected breakables
        for name in pairs(breakablePriorities) do
            if not currentlySelected[name] then
                breakablePriorities[name] = nil
            end
        end

        -- Add newly selected breakables with incrementing priority
        for name, selected in pairs(value) do
            if selected and not breakablePriorities[name] then
                breakablePriorities[name] = nextPriority
                nextPriority = nextPriority + 1
            end
        end

        updateBreakablePriorityDisplay()
    end
})

-- Get all breakables in current world & zone grouped by suffix name (no prefix)
local function getBreakablesInCurrentZone()
    local currentWorld = WorldController.Current or "World1"
    local worldNumber = tonumber(currentWorld:match("World(%d+)")) or 1
    local currentZone = ZoneController.Current or 1
    local currentPrefix = string.format("W%d_Z%d_", worldNumber, currentZone)

    local breakableObjectsByName = {}

    if BreakableController.Breakables then
        for _, breakable in pairs(BreakableController.Breakables) do
            local breakableWorldStr = tostring(breakable.World)
            local breakableWorldNum = tonumber(breakableWorldStr:match("World(%d+)")) or tonumber(breakableWorldStr) or 1
            local zone = breakable.Zone

            if breakableWorldNum == worldNumber and zone == currentZone then
                -- Find enum name by ID
                local enumName = "Unknown"
                for name, id in pairs(BreakablesEnum) do
                    if id == breakable.ID then
                        enumName = name
                        break
                    end
                end
                local suffixName = getSuffixName(enumName)

                breakableObjectsByName[suffixName] = breakableObjectsByName[suffixName] or {}
                table.insert(breakableObjectsByName[suffixName], breakable)
            end
        end
    end

    return breakableObjectsByName
end

-- findClosestPriorityBreakable and other logic remain same but use suffix names for priority keys

local function findClosestPriorityBreakable()
    local breakableObjects = getBreakablesInCurrentZone()
    if not breakableObjects or not next(breakableObjects) then
        return nil
    end

    local closestBreakable = nil
    local closestDistance = math.huge

    local character = LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local charPos = hrp.Position

    for name, objects in pairs(breakableObjects) do
        if breakablePriorities[name] and #objects > 0 then
            for _, obj in ipairs(objects) do
                local dist = (obj.Position - charPos).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestBreakable = obj
                end
            end
        end
    end

    return closestBreakable
end


-- Teleport player near breakable
local function teleportToBreakable(breakable)
    if not breakable or not breakable.Position then return false end

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local offset = Vector3.new(0, 3, 0)
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(breakable.Position + offset)

        if AFKModule then
            pcall(function()
                AFKModule.Set("Breakables")
            end)
        end

        return true
    end
    return false
end

-- Attack breakable via Knit service safely
local function attackBreakable()
    pcall(function()
        local BreakableAttackService = ReplicatedStorage.Shared.Packages.Knit.Services.BreakableAttackService
        if BreakableAttackService and BreakableAttackService.RF and BreakableAttackService.RF.attack then
            BreakableAttackService.RF.attack:InvokeServer()
        end
    end)
end

-- Main auto train toggle
local autoTrainEnabled = false
local autoTrainConnection = nil

AutoTrain = AutoCollectSection:AddToggle("AutoTrainToggle", {
    Title = "Auto Train",
    Description = "Automatically teleport to and attack breakables based on priority",
    Default = false,
    Callback = function(enabled)
        autoTrainEnabled = enabled

        if enabled then
            autoTrainConnection = task.spawn(function()
                while autoTrainEnabled do
                    -- Find closest prioritized breakable
                    target = findClosestPriorityBreakable()

                    -- Fallback if no priority breakable found
                    if not target then
                        local breakableObjects = getBreakablesInCurrentZone()
                        local sizeKeywords = {"LARGE", "MEDIUM", "SMALL"}

                        local foundFallback = false
                        for _, size in ipairs(sizeKeywords) do
                            for name, objects in pairs(breakableObjects) do
                                if name:upper():find(size) and #objects > 0 then
                                    target = objects[1]
                                    foundFallback = true
                                    break
                                end
                            end
                            if foundFallback then break end
                        end

                        if not foundFallback then
                            for _, objects in pairs(breakableObjects) do
                                if #objects > 0 then
                                    target = objects[1]
                                    break
                                end
                            end
                        end
                    end

                    if target then
                        teleportToBreakable(target)
                    end

                    -- Attack breakable rapidly every 0.001 seconds,
                    -- but teleport/update target every 0.01 seconds in this loop
                    local attackStart = tick()
                    while autoTrainEnabled and tick() - attackStart < 0.01 do
                        attackBreakable()
                        task.wait(0.001)
                    end

                    task.wait(0) -- yield briefly to prevent locking up
                end
            end)
        else
            if autoTrainConnection then
                task.cancel(autoTrainConnection)
                autoTrainConnection = nil
            end
        end
    end
})

-- Initialize the priority display
updateBreakablePriorityDisplay()

local autoCollectEnabled = false
local autoCollectCoroutine = nil

AutoCollectSection:AddToggle("AutoCollectDrops", {
    Title = "Auto Collect Drops",
    Description = "Collect Dropped Items/Strength",
    Default = false,
    Callback = function(enabled)
        autoCollectEnabled = enabled

        if enabled then
            autoCollectCoroutine = task.spawn(function()
                local Players = game:GetService("Players")
                local player = Players.LocalPlayer
                while autoCollectEnabled do
                    local character = player.Character or player.CharacterAdded:Wait()
                    local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart")
                    local drops = workspace:FindFirstChild("__DROPS__") or workspace:WaitForChild("__DROPS__")
                    for _, drop in ipairs(drops:GetChildren()) do
                        if drop:IsA("BasePart") then
                            drop.CFrame = hrp.CFrame
                        end
                    end
                    task.wait(3)
                end
            end)
        else
            if autoCollectCoroutine then
                task.cancel(autoCollectCoroutine)
                autoCollectCoroutine = nil
            end
        end
    end
})

-- === AUTO FIGHT SECTION ===
AutoFightSection = Tabs.AutoFarm:AddSection("OP Auto Fight")

-- Function to extract world and boss number from key
local function getWorldAndBossNumber(key)
    local world, boss = string.match(tostring(key), "World(%d+)Boss(%d+)")
    if world and boss then
        return world, boss
    else
        return nil, nil
    end
end

-- Load bosses directly from the enum
local success, BossesEnum = pcall(function()
    return require(ReplicatedStorage.Shared.Enums.Bosses)
end)

local bossNames = {}
local bossKeyMap = {}

if success and BossesEnum then
    for bossName, bossValue in pairs(BossesEnum) do
        table.insert(bossNames, bossName)
        bossKeyMap[bossName] = bossValue
    end
    
    -- Sort the boss names
    table.sort(bossNames, function(a, b)
        local aWorld, aBoss = string.match(a, "World(%d+)Boss(%d+)")
        local bWorld, bBoss = string.match(b, "World(%d+)Boss(%d+)")
        aWorld, aBoss = tonumber(aWorld), tonumber(aBoss)
        bWorld, bBoss = tonumber(bWorld), tonumber(bBoss)
        if aWorld == bWorld then
            return aBoss < bBoss
        end
        return aWorld < bWorld
    end)
end

BossDropdown = AutoFightSection:AddDropdown("BossSelect", {
    Title = "Select Boss",
    Description = "Choose a boss to auto fight.",
    Values = bossNames,
    Multi = false,
    Searchable = true,
    Default = bossNames[1] or nil,
    Callback = function(selectedBoss)
        local key = bossKeyMap[selectedBoss]
        if key then
            local worldNum, bossNum = getWorldAndBossNumber(key)
            if worldNum and bossNum then
                -- Handle boss selection
            end
        end
    end
})

local toggleEnabled = false

local AutoFightToggle = AutoFightSection:AddToggle("AutoFightToggle", {
    Title = "Auto Fight",
    Description = "Automatically fights the selected boss repeatedly.",
    Default = false,
    Callback = function(enabled)
        toggleEnabled = enabled  -- Track toggle state globally

        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer

        local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
        local autoFightModule = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Normal.Battling.BattleAutoFightController)
        local battleNpcController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Normal.Battling.BattleNpcController)
        local AttackService = ReplicatedStorage.Shared.Packages.Knit.Services.BattleAttackService

        local selectedBoss = BossDropdown.Value
        local bossKey = bossKeyMap[selectedBoss]
        local worldNum, bossNum = getWorldAndBossNumber(bossKey)
        local worldName = "World" .. tostring(worldNum)
        local isFighting = false

        local function startBattle()
            if worldName and bossNum and not isFighting then
                isFighting = true
                local args = {
                    [1] = worldName,
                    [2] = tonumber(bossNum)
                }

                local success, err = pcall(function()
                    ReplicatedStorage.Shared.Packages.Knit.Services.BattleService.RF.startPvE:InvokeServer(unpack(args))
                end)

                if not success then
                    isFighting = false
                end
            end
        end

        local function attackBoss(bossId, npc)
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") and npc and npc:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = CFrame.new(npc.HumanoidRootPart.Position + Vector3.new(5, 0, 0))
                local args = {
                    [1] = {
                        [1] = tostring(bossId)
                    }
                }
                pcall(function()
                    AttackService.RF.attack:InvokeServer(unpack(args))
                end)
            end
        end

        if toggleEnabled then
            autoFightModule:KnitStart()

            -- Start the first battle
            startBattle()

            -- Replace onSpawnBosses
            if not battleNpcController._originalOnSpawnBosses then
                battleNpcController._originalOnSpawnBosses = battleNpcController.onSpawnBosses
            end

            battleNpcController.onSpawnBosses = function(self, ...)
                local originalBosses = {}
                for k, v in pairs(self.Bosses) do
                    originalBosses[k] = v
                end

                local result = battleNpcController._originalOnSpawnBosses(self, ...)

                for bossId, bossData in pairs(self.Bosses) do
                    if not originalBosses[bossId] and bossData.NPC then
                        attackBoss(bossId, bossData.NPC)
                    end
                end

                return result
            end

            -- Connect to onBattleEnded to restart fight
            local BattleService = Knit.GetService("BattleService")
            if BattleService and BattleService.onBattleEnded then
                BattleService.onBattleEnded:Connect(function(...)
                    isFighting = false
                    if toggleEnabled then
                        task.delay(0.5, function()
                            if toggleEnabled then
                                startBattle()
                            end
                        end)
                    end
                end)
            else
            end

            -- Loop to attack closest boss every 0.2 seconds
            task.spawn(function()
                while toggleEnabled do
                    local character = LocalPlayer.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        local hrp = character.HumanoidRootPart
                        local closestBossId, closestBossNpc
                        local shortestDist = math.huge

                        for bossId, bossData in pairs(battleNpcController.Bosses) do
                            local npc = bossData.NPC
                            if npc and npc:FindFirstChild("HumanoidRootPart") then
                                local dist = (hrp.Position - npc.HumanoidRootPart.Position).Magnitude
                                if dist < shortestDist then
                                    shortestDist = dist
                                    closestBossId = bossId
                                    closestBossNpc = npc
                                end
                            end
                        end

                        if closestBossId and closestBossNpc then
                            attackBoss(closestBossId, closestBossNpc)
                        end
                    end

                    task.wait(0.2)
                end
            end)
        else
            isFighting = false

            -- Restore original spawn boss handler
            if battleNpcController._originalOnSpawnBosses then
                battleNpcController.onSpawnBosses = battleNpcController._originalOnSpawnBosses
            end
        end
    end
})

AutoFightSection:AddToggle("NeverLoseToggle", {
    Title = "Never Lose",
    Description = "You will no longer take damage from bosses (rejoining resets this).",
    Default = false,
    Callback = function(enabled)
        local attackRemote = ReplicatedStorage.Shared.Packages.Knit.Services.BattleAttackService.RF.attackPlayer
        local mt = getrawmetatable(game)
        setreadonly(mt, false)

        if enabled then
            if getgenv().NamecallBlocked then
                setreadonly(mt, true)
                return
            end
            getgenv().NamecallBlocked = true
            getgenv().OldNamecall = mt.__namecall

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                if self == attackRemote and method == "InvokeServer" then
                    return nil
                end
                return getgenv().OldNamecall(self, ...)
            end)
        else
            if getgenv().NamecallBlocked and getgenv().OldNamecall then
                mt.__namecall = getgenv().OldNamecall
                getgenv().NamecallBlocked = false
                getgenv().OldNamecall = nil
            end
        end

        setreadonly(mt, true)
    end
})

AutoFightSection1 = Tabs.AutoFarm:AddSection("Glitch Fix")


local savedWalkSpeed = nil

local function saveWalkSpeed()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        savedWalkSpeed = humanoid.WalkSpeed
    else
        warn("Humanoid not found when saving WalkSpeed")
    end
end

saveWalkSpeed()

local UserInputService = game:GetService("UserInputService")
local maxJumps = 2
local jumpCount = 0
local jumpConnection
local stateConnection


local function resetCharacterState()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if not humanoid then
        warn("Humanoid not found")
        return
    end

    -- Reset WalkSpeed and JumpPower
    humanoid.WalkSpeed = savedWalkSpeed or 16
    humanoid.JumpPower = 50

    -- Disconnect previous connections if any (to avoid duplicates)
    if jumpConnection then jumpConnection:Disconnect() end
    if stateConnection then stateConnection:Disconnect() end

    jumpCount = 0

    -- Reset jump count when player lands
    stateConnection = humanoid.StateChanged:Connect(function(oldState, newState)
        if newState == Enum.HumanoidStateType.Landed then
            jumpCount = 0
        end
    end)

    -- Listen for jump requests to allow double jump with velocity boost
    jumpConnection = UserInputService.JumpRequest:Connect(function()
        if jumpCount < maxJumps then
            if jumpCount > 0 then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)

                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    rootPart.Velocity = Vector3.new(rootPart.Velocity.X, 50, rootPart.Velocity.Z)
                end
            end
            jumpCount = jumpCount + 1
        end
    end)
end

AutoFightSection1:AddButton({
    Title = "Glitch Fix",
    Description = "Sometimes the player can't move after turning off this toggle. This should fix it.",
    Callback = function()
        if LocalPlayer and LocalPlayer.Character then
            resetCharacterState()
        end
    end
})




-- === EGGS SECTION ===
EggsSection = Tabs.Eggs:AddSection("Eggs")

noteegg = Tabs.Eggs:AddParagraph("Note", {
    Title = "Note",
    Content = "For the eggs/sword chests, W = World, and Z = Zone.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local success, EggTypes = pcall(function()
    return require(ReplicatedStorage.Shared.Enums.EggTypes)
end)

if not success then
    return
end

-- Collect and parse matching entries for EGGS
local eggEntries = {}

for key, value in pairs(EggTypes) do
    if type(value) == "string" then
        local w, z = string.match(value, "^W(%d+)_Z(%d+)")
        if w and z then
            table.insert(eggEntries, {
                key = key,
                value = value,
                w = tonumber(w),
                z = tonumber(z)
            })
        end
    end
end

-- Sort by world and zone (with nil checks)
table.sort(eggEntries, function(a, b)
    -- Check for nil values first
    if not a and not b then return false end
    if not a then return true end
    if not b then return false end

    -- Now check for w and z
    if not a.w and not b.w then return false end
    if not a.w then return true end
    if not b.w then return false end

    if not a.z and not b.z then return false end
    if not a.z then return true end
    if not b.z then return false end

    if a.w == b.w then
        return a.z < b.z
    else
        return a.w < b.w
    end
end)

-- Build dropdown values (egg names)
local eggNames = {}
for _, entry in ipairs(eggEntries) do
    table.insert(eggNames, entry.key)
end

-- Ensure we have at least one egg
if #eggNames == 0 then
    return
end

SelectedEgg = nil -- Store the actual enum value
local hatchAmount = 1
local autoBuyEnabled = false

EggDropdown = EggsSection:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Searchable = true,
    Default = eggNames[1],
    Callback = function(value)
        -- Find the corresponding enum value
        for _, entry in ipairs(eggEntries) do
            if entry.key == value then
                SelectedEgg = entry.value
                break
            end
        end
    end
})

-- Set initial selected egg value
if eggNames[1] then
    for _, entry in ipairs(eggEntries) do
        if entry.key == eggNames[1] then
            SelectedEgg = entry.value
            break
        end
    end
end

HatchAmountInput = EggsSection:AddInput("HatchAmountInput", {
    Title = "Hatch Amount",
    Description = "Enter the number of eggs to hatch\n(must own).",
    Placeholder = "1",
    Numeric = true,
    Default = "1",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            hatchAmount = math.floor(num)
        else
            hatchAmount = 1
        end
    end
})

-- ...existing code...

local superHatchEnabled = false

EggsSection:AddToggle("SuperHatchToggle", {
    Title = "Super Hatch",
    Description = "Hatch eggs with Super Hatch enabled (uses true for the third argument).",
    Default = false,
    Callback = function(enabled)
        superHatchEnabled = enabled
    end
})

local autoBuyCoroutine = nil

AutoBuyEggToggle = EggsSection:AddToggle("Auto Buy Egg", {
    Title = "Auto Buy Egg",
    Description = "Automatically buys the selected egg with the specified hatch amount.",
    Default = false,
    Callback = function(enabled)
        autoBuyEnabled = enabled

        if enabled then
            autoBuyCoroutine = task.spawn(function()
                while autoBuyEnabled do
                    if SelectedEgg and hatchAmount > 0 then
                        local success, err = pcall(function()
                            local args = {
                                [1] = SelectedEgg,
                                [2] = hatchAmount,
                                [3] = superHatchEnabled and true or false
                            }
                            EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                        end)
                    end
                    task.wait(0.1)
                end
            end)
        else
            if autoBuyCoroutine then
                task.cancel(autoBuyCoroutine)
                autoBuyCoroutine = nil
            end
        end
    end
})

-- Sword Chests Section
ChestSection = Tabs.Eggs:AddSection("Sword Chests")

local chestNames = {}
for i, entry in ipairs(eggEntries) do
    if entry and entry.key then
        if type(entry.key) == "string" then
            local formattedName = string.gsub(entry.key, "_", "")
            if type(formattedName) == "string" then
                table.insert(chestNames, formattedName)
            end
        end
    end
end

ChestDropdown = ChestSection:AddDropdown("SelectChestDropdown", {
    Title = "Select Chest",
    Description = "Choose a sword chest.",
    Values = chestNames,
    Multi = false,
    Default = chestNames[1] or nil,
    Callback = function(value)
    end
})

local autoOpenEnabled = false
local autoOpenCoroutine = nil

AutoOpenChestToggle = ChestSection:AddToggle("AutoOpenChestToggle", {
    Title = "Auto Open",
    Description = "Automatically opens the selected sword chest.",
    Default = false,
    Callback = function(enabled)
        autoOpenEnabled = enabled
        
        if enabled then
            autoOpenCoroutine = task.spawn(function()
                while autoOpenEnabled do
                    local CrateArg = ChestDropdown.Value
                    if CrateArg then
                        -- Remove spaces if any, just in case
                        local crateArg = tostring(CrateArg)
                        local args = {
                            [1] = crateArg
                        }

                        if SwordCrateService and SwordCrateService.RF and SwordCrateService.RF.open then
                            local success, result = pcall(function()
                                SwordCrateService.RF.open:InvokeServer(unpack(args))
                            end)
                        end
                    end
                    task.wait(1)
                end
            end)
        else
            if autoOpenCoroutine then
                task.cancel(autoOpenCoroutine)
                autoOpenCoroutine = nil
            end
        end
    end
})

-- === UPGRADES SECTION ===
UpgradesSection = Tabs.Upgrades:AddSection("Stats")

statsInfo = UpgradesSection:AddParagraph("UpgradeStats", {
    Title = "Upgrade Statistics",
    Content = "Loading...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Function to update stats
local function updateStats()
    local ownedUpgrades = DataController:GetValue({"UpgradeTree"})
    local currentPoints = DataController:GetValue({"UpgradePoints"}) or 0
    
    -- Get the upgrade tree data
    local UpgradeTree = require(ReplicatedStorage.Shared.Balancing.Shared.UpgradeTree)
    
    -- Count total upgrades and calculate total cost
    local totalUpgrades = 0
    local totalCost = 0
    local ownedLookup = {}
    
    -- Create lookup table for owned upgrades
    for _, id in pairs(ownedUpgrades) do
        ownedLookup[id] = true
    end
    
    -- Count total upgrades and calculate cost of missing ones
    for _, upgrade in pairs(UpgradeTree) do
        if type(upgrade) == "table" and not upgrade.Back then
            totalUpgrades = totalUpgrades + 1
            if not ownedLookup[upgrade.ID] then
                local cost = (type(upgrade.Cost) == "table" and upgrade.Cost.Amount) or 0
                totalCost = totalCost + cost
            end
        end
    end
    
    local ownedCount = #ownedUpgrades
    local missingCount = totalUpgrades - ownedCount
    
    -- Update the paragraph
    statsInfo:SetValue(string.format(
        "\nCurrent Upgrade Points: %d\n\nOwned Upgrades: %d\nMissing Upgrades: %d\nTotal Upgrades: %d\n\nTotal Cost for Missing Upgrades: %d",
        currentPoints,
        ownedCount,
        missingCount,
        totalUpgrades,
        totalCost
    ))
end

-- Initial update
updateStats()

-- Update every 5 seconds
task.spawn(function()
    while true do
        task.wait(5)
        updateStats()
    end
end)

local autoBuyUpgradesEnabled = false
local autoBuyUpgradesCoroutine = nil

UpgradesSection:AddToggle("AutoBuyUpgrades", {
    Title = "Auto Buy Upgrades",
    Description = "Automatically buy affordable upgrades.",
    Default = false,
    Callback = function(enabled)
        autoBuyUpgradesEnabled = enabled

        if enabled then
            autoBuyUpgradesCoroutine = task.spawn(function()
                while autoBuyUpgradesEnabled do
                    local ownedUpgrades = DataController:GetValue({"UpgradeTree"})
                    local currentPoints = DataController:GetValue({"UpgradePoints"}) or 0
                    local UpgradeTree = require(ReplicatedStorage.Shared.Balancing.Shared.UpgradeTree)

                    -- Build lookup for owned upgrades
                    local ownedLookup = {}
                    for _, id in pairs(ownedUpgrades) do
                        ownedLookup[id] = true
                    end

                    local boughtAny = false

                    for _, upgrade in pairs(UpgradeTree) do
                        if type(upgrade) == "table" and not upgrade.Back and not ownedLookup[upgrade.ID] then
                            local cost = (type(upgrade.Cost) == "table" and upgrade.Cost.Amount) or 0
                            if currentPoints >= cost and cost > 0 then
                                local args = { upgrade.ID }
                                pcall(function()
                                    UpgradeTreeService.RF.unlock:InvokeServer(unpack(args))
                                end)
                                boughtAny = true
                                task.wait(1) -- Wait 1 second after buying
                                break -- Only buy one per second
                            end
                        end
                    end

                    if not boughtAny then
                        task.wait(3) -- Wait 3 seconds if nothing affordable
                    end
                end
            end)
        else
            if autoBuyUpgradesCoroutine then
                task.cancel(autoBuyUpgradesCoroutine)
                autoBuyUpgradesCoroutine = nil
            end
        end
    end
})

-- Quest handling
QuestsFolder = ReplicatedStorage.Shared.Data.Core.Quests
local QuestController = require(LocalPlayer.PlayerScripts.Client.Controllers.Shared.Core.QuestController)

-- Quests to exclude
local excludedQuests = {
    ["Craft Enchants"] = true,
    ["Craft Potions"] = true,
    ["Buy an upgrade!"] = true,
    ["Earn XP"] = true,
    ["Playtime"] = true,
    ["Purchase the next area!"] = true,
    ["Use Plantables"] = true,
    ["Mine Blocks"] = true
}

-- Get all quest titles and IDs and sort them alphabetically
local questTitles = {}
local questMap = {}
local moduleInfo = {}

-- First get all module info by ID
for _, questModule in pairs(QuestsFolder:GetChildren()) do
    local quest = require(questModule)
    local success, title = pcall(function() return quest:GetTitle() end)
    if success and title and not excludedQuests[title] then
        moduleInfo[quest.ID] = {
            title = title,
            module = questModule.Name,
            event = quest.Event,
            id = quest.ID
        }
        table.insert(questTitles, title)
        questMap[title] = quest.ID
    end
end
table.sort(questTitles)

-- Function to check if a quest is active and get its data
local function getQuestData(questId)
    for activeId, activeQuest in pairs(QuestController.Current) do
        if activeQuest.Name and activeQuest.Type == questId then
            return activeQuest
        end
    end
    return nil
end


-- Add the section to Upgrades tab
QuestSection = Tabs.Upgrades:AddSection("Auto Quest")

QuestNote = QuestSection:AddParagraph("QuestNote", {
    Title = "Note",
    Content = "Quests that involve hatching, breaking, bosses, etc, will use your selected values from other dropdowns. If the quest requires you to gold pets, this will hatch the selected egg and gold the EASY pets from it. Some quest names are different to what you will see, but will still be auto completed.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Variable to store selected quests
local selectedQuests = {}

-- Create dropdown for quest selection
QuestDropdown = QuestSection:AddDropdown("QuestSelect", {
    Title = "Select Quest",
    Description = "Choose which quest to auto-complete",
    Values = questTitles,
    Multi = true,
    Searchable = true,
    Default = {},
    Callback = function(value)
        selectedQuests = value or {}
    end
})

-- Add Select All button
QuestSection:AddButton({
    Title = "Select All",
    Description = "Select all available quests",
    Callback = function()
        local allSelected = {}
        for _, title in ipairs(questTitles) do
            allSelected[title] = true
        end
        QuestDropdown:SetValue(allSelected)
    end
})

local EggsModule = require(ReplicatedStorage.Shared.Balancing.Shared.Eggs)
local PetsEnum = require(ReplicatedStorage.Shared.Enums.Pets)

-- ...existing code...

local function isQuestActive(questId)
    for _, activeQuest in pairs(QuestController.Current) do
        if activeQuest.Type == questId and not activeQuest.Completed then
            return true, activeQuest
        end
    end
    return false, nil
end

local function completeQuest(questName, questData)
    if not questData then return end

    -- Always run if quest is active, even if progress is x/x
    local function runWhileActive(action, interval)
        interval = interval or 1
        while autoCompleteEnabled do
            local activeQuest = getQuestData(questData.Type)
            if not activeQuest then break end
            action(activeQuest)
            task.wait(interval)
        end
    end

    if questName == "Upgrade Pets" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                local egg = EggsModule.Eggs[SelectedEgg]
                if egg and egg.Loot and egg.Loot.Rewards then
                    local commonPets = {}
                    for petId, chance in pairs(egg.Loot.Rewards) do
                        if type(petId) ~= "string" and chance > 15 then
                            for petName, enumId in pairs(PetsEnum) do
                                if enumId == petId then
                                    table.insert(commonPets, { id = tostring(enumId) .. "-1", chance = chance })
                                    break
                                end
                            end
                        end
                    end
                    EggService.RF.purchaseEgg:InvokeServer(SelectedEgg, hatchAmount, false)
                    if #commonPets > 0 then
                        local randomPet = commonPets[math.random(1, #commonPets)]
                        GoldMachineService.RF.craft:InvokeServer(randomPet.id, 5)
                    end
                end
            end, 1)
        end)
    end

    local originalAutoFightState = AutoFightToggle.Value

    if questName == "Kill Bosses" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                if not AutoFightToggle.Value then
                    AutoFightToggle:SetValue(true)
                end
            end, 1)
            if not originalAutoFightState then
                AutoFightToggle:SetValue(false)
            end
        end)
    end

    if questName == "Win Battles" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                if not AutoFightToggle.Value then
                    AutoFightToggle:SetValue(true)
                end
            end, 1)
            if not originalAutoFightState then
                AutoFightToggle:SetValue(false)
            end
        end)
    end

    if questName == "Open Sword Chests" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                SwordCrateService.RF.open:InvokeServer(ChestDropdown.Value or "W1Z1")
            end, 1)
        end)
    end

    if questName == "Hatch Eggs" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                EggService.RF.purchaseEgg:InvokeServer(SelectedEgg or "W1_Z1", hatchAmount or 1, false)
            end, 1)
        end)
    end

    if questName == "Break Breakables" then
        task.spawn(function()
            local originalAutoTrainState = autoTrainEnabled
            if not autoTrainEnabled then
                AutoTrain:SetValue(true)
            end
            runWhileActive(function(currentQuest) end, 1)
            if not originalAutoTrainState then
                AutoTrain:SetValue(false)
            end
        end)
    end

    if questName == "Use Potions" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                local potionController = Knit.GetController("PotionController")
                local PotionTypes = require(ReplicatedStorage.Shared.Enums.PotionTypes)
                local storage = potionController.Storage or {}
                local mostPotion = { id = nil, tier = nil, count = 0 }
                for potionId, tiers in pairs(storage) do
                    for tier, amount in pairs(tiers) do
                        amount = tonumber(amount) or 0
                        tier = tonumber(tier) or 1
                        if tier <= 3 and amount > mostPotion.count then
                            mostPotion.id = potionId
                            mostPotion.tier = tier
                            mostPotion.count = amount
                        end
                    end
                end
                if mostPotion.id and mostPotion.count > 0 then
                    local potionName = "Wins"
                    for enumName, id in pairs(PotionTypes) do
                        if id == mostPotion.id then
                            potionName = enumName
                            break
                        end
                    end
                    game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PotionUseService.RF.use:InvokeServer(potionName, mostPotion.tier, 1)
                end
            end, 1)
        end)
    end

    if questName == "Open Gifts" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                local BackpackInventoryController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Shared.Utility.Backpack.BackpackInventoryController)
                local giftCategory = BackpackInventoryController.Amounts.GiftConsumables or {}
                local maxAmount, bestGiftBag = 0, nil
                for itemName, data in pairs(giftCategory) do
                    if type(data) == "table" then
                        for nestedName, nestedAmount in pairs(data) do
                            if nestedAmount > maxAmount then
                                maxAmount = nestedAmount
                                bestGiftBag = nestedName
                            end
                        end
                    else
                        if data > maxAmount then
                            maxAmount = data
                            bestGiftBag = itemName
                        end
                    end
                end
                if bestGiftBag and maxAmount > 0 then
                    ReplicatedStorage.Shared.Packages.Knit.Services.GiftBagService.RF.openGift:InvokeServer(bestGiftBag, 1)
                end
            end, 1)
        end)
    end

    if questName == "Swing Sword" then
        task.spawn(function()
            runWhileActive(function(currentQuest)
                ReplicatedStorage.Shared.Packages.Knit.Services.SwordAttackService.RF.swing:InvokeServer()
            end, 0.25)
        end)
    end
end

-- Update the auto-complete toggle callback
QuestSection:AddToggle("AutoCompleteQuest", {
    Title = "Auto Complete Quest",
    Description = "Automatically complete selected quests",
    Default = false,
    Callback = function(enabled)
        autoCompleteEnabled = enabled

        if enabled then
            task.spawn(function()
                while autoCompleteEnabled do
                    for title, isSelected in pairs(selectedQuests) do
                        if isSelected then
                            local questId = questMap[title]
                            local questData = getQuestData(questId)
                            if questData then
                                completeQuest(title, questData)
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
        end
    end
})


-- Add a paragraph to show current quest progress
questInfoParagraph = QuestSection:AddParagraph("QuestInfo", {
    Title = "Selected Quests Progress",
    Content = "Select quests to see progress",
})

-- Update quest progress every 5 seconds
task.spawn(function()
    while true do
        local progressText = ""
        local progressEntries = {}
        
        for title, isSelected in pairs(selectedQuests) do
            if isSelected then
                local questId = questMap[title]
                local questData = getQuestData(questId)
                
                if questData then
                    table.insert(progressEntries, {
                        title = title,
                        text = string.format(
                            "%s: %d/%d (Active Quest)",
                            title,
                            questData.Progress or 0,
                            questData.Goal or 0,
                            tostring(questData.Completed)
                        )
                    })
                else
                    table.insert(progressEntries, {
                        title = title,
                        text = title .. " (Not Currently Active)"
                    })
                end
            end
        end
        
        table.sort(progressEntries, function(a, b) return a.title < b.title end)
        
        for _, entry in ipairs(progressEntries) do
            progressText = progressText .. entry.text .. "\n"
        end
        
        questInfoParagraph:SetValue(progressText ~= "" and progressText or "No quests selected")
        task.wait(5)
    end
end)

-- === TELEPORT SECTION ===
TeleportSection = Tabs.Teleport:AddSection("Breakable Spawns")

local breakables = workspace:WaitForChild("Core_Game"):WaitForChild("Breakables")

local function addSpawnButtons(parent, prefix)
    prefix = prefix or ""
    for _, child in pairs(parent:GetChildren()) do
        local path = prefix .. child.Name
        if child.Name == "Spawn" then
            -- Parse World and Zone from the path
            local world, zone = string.match(path, "World(%d+)%.(%d+)%.Spawn")
            local buttonTitle
            if world and zone then
                buttonTitle = "World " .. world .. " Zone " .. zone
            else
                buttonTitle = path
            end
            TeleportSection:AddButton({
                Title = buttonTitle,
                Description = "Teleport to " .. buttonTitle,
                Callback = function()
                    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(child.Position)
                    end
                end
            })
        end
        if #child:GetChildren() > 0 then
            addSpawnButtons(child, path .. ".")
        end
    end
end

addSpawnButtons(breakables)

-- === MACHINES SECTION ===
MachinesSection = Tabs.Machines:AddSection("Gold Machine")

local TierNames = {}
for name, number in pairs(ItemTiersEnum) do
    TierNames[number] = name
end

local function collectUnlockedTier1PetsFromGui()
    local petController = Knit.GetController("PetController")
    local petDataStore = petController.Pets
    local playerGui = LocalPlayer.PlayerGui
    local inventory = playerGui.GameUI.MainFrames.Inventory.Inner.Holder.Inner.Pages.Pets.Contents.Contents.Inventory
    local equippedInventory = playerGui.GameUI.MainFrames.Inventory.Inner.Holder.Inner.Pages.Pets.Contents.Contents.Equipped_Inventory

    local pets = {}
    local seenNames = {}

    local function collect(folder)
        for _, child in pairs(folder:GetChildren()) do
            if child:IsA("ImageButton") then
                local id = child:GetAttribute("ID")
                local tier = child:GetAttribute("Tier")
                if id and tier and tonumber(tier) == 1 then
                    local tierName = TierNames[tier] or "Unknown"
                    local fullKey = id .. "-" .. tier
                    local petData = petDataStore[fullKey]
                    if petData and petData.L == false then
                        local guiName = string.match(child.Name, "^nil%-(.-)%-.+%-.+") or "Unknown"
                        local fullName = (tierName ~= "Normal" and tierName .. " " or "") .. guiName
                        if not seenNames[fullName] then
                            seenNames[fullName] = true
                            table.insert(pets, {
                                Name = fullName,
                                Quantity = petData.Q or 0,
                                ID = id,
                                Tier = tonumber(tier),
                            })
                        end
                    end
                end
            end
        end
    end

    collect(inventory)
    collect(equippedInventory)
    return pets
end

-- Store reference to current pets data
local unlockedTier1Pets = collectUnlockedTier1PetsFromGui()

local function getPetNames()
    local petNames = {}
    local nameSet = {}
    for _, pet in ipairs(unlockedTier1Pets) do
        if not nameSet[pet.Name] then
            table.insert(petNames, pet.Name)
            nameSet[pet.Name] = true
        end
    end
    return petNames
end

petInfoParagraph = MachinesSection:AddParagraph("PetInfo", {
    Title = "Pet Info",
    Content = "Selected Pets",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Function to update pet info display
local function updatePetInfoDisplay(selectedNamesDict, previousSelection)
    -- Refresh pet data to get current quantities
    unlockedTier1Pets = collectUnlockedTier1PetsFromGui()
    
    local lines = {}
    local nameSet = {}
    
    for selectedName, isSelected in pairs(selectedNamesDict) do
        if isSelected and not nameSet[selectedName] then
            for _, pet in ipairs(unlockedTier1Pets) do
                if pet.Name == selectedName then
                    table.insert(lines, string.format("%s - %dx", pet.Name, pet.Quantity))

                    if not previousSelection or not previousSelection[selectedName] then
                    end
                    
                    nameSet[selectedName] = true
                    break
                end
            end
        end
    end
    petInfoParagraph:SetValue(#lines > 0 and table.concat(lines, "\n") or "Select pets to see their name and quantity.")
end

-- Store previous selection to track changes
local previousSelection = {}

petDropdown = MachinesSection:AddDropdown("UnlockedTier1PetsDropdown", {
    Title = "Select Pets to turn Golden",
    Description = "Select unlocked pets.",
    Values = getPetNames(),
    Multi = true,
    Default = {},
    Searchable = true,
    Callback = function(selectedNamesDict)
        updatePetInfoDisplay(selectedNamesDict, previousSelection)
        -- Update previous selection for next comparison
        previousSelection = {}
        for name, isSelected in pairs(selectedNamesDict) do
            previousSelection[name] = isSelected
        end
    end
})

-- Button to refresh pet list
MachinesSection:AddButton({
    Title = "Refresh Pet List",
    Description = "Update the list of available pets",
    Callback = function()
        -- Refresh the pets data
        unlockedTier1Pets = collectUnlockedTier1PetsFromGui()
        
        -- Get updated pet names
        local updatedPetNames = getPetNames()
        
        -- Update the dropdown values
        petDropdown:SetValues(updatedPetNames)
        
        -- Update the display with current selection
        local currentSelection = petDropdown.Value or {}
        updatePetInfoDisplay(currentSelection, previousSelection)
        
        -- Update previous selection after refresh
        previousSelection = {}
        for name, isSelected in pairs(currentSelection) do
            previousSelection[name] = isSelected
        end
    end
})

-- Auto Gold Pets functionality
local autoGoldEnabled = false
local autoGoldConnection = nil

autoGoldToggle = MachinesSection:AddToggle("AutoGoldPets", {
    Title = "Auto Gold Pets",
    Description = "Automatically gold selected pets (if enough pets are owned).",
    Default = false,
    Callback = function(enabled)
        autoGoldEnabled = enabled
        
        if enabled then           
            -- Start the auto gold loop
            autoGoldConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not autoGoldEnabled then return end
                
                local selectedPets = petDropdown.Value or {}
                
                for petName, isSelected in pairs(selectedPets) do
                    if isSelected then
                        -- Find the pet data
                        for _, pet in ipairs(unlockedTier1Pets) do
                            if pet.Name == petName and pet.Quantity >= 5 then
                                local petId = pet.ID .. "-" .. pet.Tier
                                
                                local args = {
                                    [1] = petId,
                                    [2] = 5
                                }
                                
                                local success, result = pcall(function()
                                    return GoldMachineService.RF.craft:InvokeServer(unpack(args))
                                end)
                                wait(1)
                                break
                            end
                        end
                    end
                end
                
                wait(1) -- Gold pets every second
            end)
        else
            -- Stop the auto gold loop
            if autoGoldConnection then
                autoGoldConnection:Disconnect()
                autoGoldConnection = nil
            end
        end
    end
})

-- Update pet quantities every 3 seconds
spawn(function()
    while true do
        local currentSelection = petDropdown.Value or {}
        if currentSelection and next(currentSelection) then
            updatePetInfoDisplay(currentSelection, previousSelection)
        end
        wait(3) -- Update every 3 seconds
    end
end)



-- === RAINBOW SECTION ===
RainbowSection = Tabs.Machines:AddSection("Rainbow Machine")

local function collectUnlockedTier2PetsFromGui()
    local petController = Knit.GetController("PetController")
    local petDataStore = petController.Pets
    local playerGui = LocalPlayer.PlayerGui
    local inventory = playerGui.GameUI.MainFrames.Inventory.Inner.Holder.Inner.Pages.Pets.Contents.Contents.Inventory
    local equippedInventory = playerGui.GameUI.MainFrames.Inventory.Inner.Holder.Inner.Pages.Pets.Contents.Contents.Equipped_Inventory

    local pets = {}
    local seenNames = {}

    local function collect(folder)
        for _, child in pairs(folder:GetChildren()) do
            if child:IsA("ImageButton") then
                local id = child:GetAttribute("ID")
                local tier = child:GetAttribute("Tier")
                if id and tier and tonumber(tier) == 2 then -- Only tier 2 (Golden)
                    local tierName = TierNames[tier] or "Unknown"
                    local fullKey = id .. "-" .. tier
                    local petData = petDataStore[fullKey]
                    if petData and petData.L == false then -- unlocked only
                        local guiName = string.match(child.Name, "^nil%-(.-)%-.+%-.+") or "Unknown"
                        local fullName = (tierName ~= "Normal" and tierName .. " " or "") .. guiName
                        if not seenNames[fullName] then
                            seenNames[fullName] = true
                            table.insert(pets, {
                                Name = fullName,
                                Quantity = petData.Q or 0,
                                ID = id,
                                Tier = tonumber(tier),
                            })
                        end
                    end
                end
            end
        end
    end

    collect(inventory)
    collect(equippedInventory)
    return pets
end

-- Store reference to current pets data
local unlockedTier2Pets = collectUnlockedTier2PetsFromGui()

local function getRainbowPetNames()
    local petNames = {}
    local nameSet = {}
    for _, pet in ipairs(unlockedTier2Pets) do
        if not nameSet[pet.Name] then
            table.insert(petNames, pet.Name)
            nameSet[pet.Name] = true
        end
    end
    return petNames
end

rainbowPetInfoParagraph = RainbowSection:AddParagraph("RainbowPetInfo", {
    Title = "Rainbow Pet Info",
    Content = "Selected Pets",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Function to update rainbow pet info display
local function updateRainbowPetInfoDisplay(selectedNamesDict, previousSelection)
    unlockedTier2Pets = collectUnlockedTier2PetsFromGui()
    
    local lines = {}
    local nameSet = {}
    
    for selectedName, isSelected in pairs(selectedNamesDict) do
        if isSelected and not nameSet[selectedName] then
            for _, pet in ipairs(unlockedTier2Pets) do
                if pet.Name == selectedName then
                    table.insert(lines, string.format("%s - %dx", pet.Name, pet.Quantity))
                    nameSet[selectedName] = true
                    break
                end
            end
        end
    end
    rainbowPetInfoParagraph:SetValue(#lines > 0 and table.concat(lines, "\n") or "Select pets to see their name and quantity.")
end

-- Store previous rainbow selection
local rainbowPreviousSelection = {}

rainbowDropdown = RainbowSection:AddDropdown("UnlockedTier2PetsDropdown", {
    Title = "Select Pets to turn Rainbow",
    Description = "Select unlocked golden pets.",
    Values = getRainbowPetNames(),
    Multi = true,
    Default = {},
    Searchable = true,
    Callback = function(selectedNamesDict)
        updateRainbowPetInfoDisplay(selectedNamesDict, rainbowPreviousSelection)
        rainbowPreviousSelection = {}
        for name, isSelected in pairs(selectedNamesDict) do
            rainbowPreviousSelection[name] = isSelected
        end
    end
})

-- Button to refresh rainbow pet list
RainbowSection:AddButton({
    Title = "Refresh Rainbow Pet List",
    Description = "Update the list of available golden pets",
    Callback = function()
        unlockedTier2Pets = collectUnlockedTier2PetsFromGui()
        local updatedPetNames = getRainbowPetNames()
        rainbowDropdown:SetValues(updatedPetNames)
        
        local currentSelection = rainbowDropdown.Value or {}
        updateRainbowPetInfoDisplay(currentSelection, rainbowPreviousSelection)
        
        rainbowPreviousSelection = {}
        for name, isSelected in pairs(currentSelection) do
            rainbowPreviousSelection[name] = isSelected
        end
    end
})

-- Auto Rainbow Pets functionality
local autoRainbowEnabled = false
local autoRainbowConnection = nil
local RainbowMachineService = Knit.GetService("RainbowMachineService")

RainbowSection:AddToggle("AutoRainbowPets", {
    Title = "Auto Rainbow Pets",
    Description = "Automatically rainbow selected pets (if enough golden pets are owned).",
    Default = false,
    Callback = function(enabled)
        autoRainbowEnabled = enabled
        
        if enabled then           
            autoRainbowConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not autoRainbowEnabled then return end
                
                local selectedPets = rainbowDropdown.Value or {}
                
                for petName, isSelected in pairs(selectedPets) do
                    if isSelected then
                        for _, pet in ipairs(unlockedTier2Pets) do
                            if pet.Name == petName and pet.Quantity >= 5 then
                                local petId = pet.ID .. "-" .. pet.Tier
                                local args = {
                                    [1] = petId,
                                    [2] = 5
                                }
                                local success, result = pcall(function()
                                    return game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.RainbowMachineService.RF.craft:InvokeServer(unpack(args))
                                end)
                                wait(1)
                                break
                            end
                        end
                    end
                end
                task.wait(1) -- Rainbow pets every second
            end)
        else
            if autoRainbowConnection then
                autoRainbowConnection:Disconnect()
                autoRainbowConnection = nil
            end
        end
    end
})

-- Update rainbow pet quantities every 3 seconds
spawn(function()
    while true do
        local currentSelection = rainbowDropdown.Value or {}
        if currentSelection and next(currentSelection) then
            updateRainbowPetInfoDisplay(currentSelection, rainbowPreviousSelection)
        end
        task.wait(3)
    end
end)

-- === PLANT SECTION ===
Plots = Tabs.Plant:AddSection("Garden Plots")

local isBuying = false

buyplottoggle = Plots:AddToggle("AutoBuyPlot", {
    Title = "Auto Buy Plot(s)",
    Description = "Automatically buy affordable plots.",
    Default = false,
    Callback = function(enabled)
        isBuying = enabled
        if enabled then
            task.spawn(function()
                local PlotData = require(ReplicatedStorage.Shared.Balancing.Shared.Crafting.PlotData)

                while isBuying do
                    -- Get current gems from GUI
                    local success, gems = pcall(function()
                        local textLabel = LocalPlayer.PlayerGui.GameUI.HUDS.Top_Middle.Inner.Currency:GetChildren()[14].TextLabel
                        local text = textLabel.Text
                        return tonumber(text:gsub(",", ""))
                    end)
                    local currentGems = success and gems or 0

                    -- Get purchased plots
                    local purchased = DataController:GetValue({ "GardenPlots", "Purchased" }) or {}
                    local missingPlots = {}
                    for plotName in pairs(PlotData.Plots) do
                        if not purchased[plotName] then
                            table.insert(missingPlots, plotName)
                        end
                    end
                    table.sort(missingPlots)

                    if #missingPlots > 0 then
                        local nextPlotName = missingPlots[1]
                        local nextPlotPrice = PlotData.Prices[#purchased + 1]
                        if currentGems >= nextPlotPrice then
                            pcall(function()
                                PlotService.RF.purchaseSlot:InvokeServer(nextPlotName)
                            end)
                            task.wait(1)
                        else
                            task.wait(5)
                        end
                    else
                        task.wait(5)
                    end
                end
            end)
        end
    end
})



AutoPlant = Tabs.Plant:AddSection("Auto Plant")

local SeedData = require(ReplicatedStorage.Shared.Balancing.Shared.Crafting.SeedData)

-- Get all seed names from SeedData
local allSeedNames = {}
for seedName, _ in pairs(SeedData) do
    table.insert(allSeedNames, seedName)
end
table.sort(allSeedNames)

local selectedSeedsToPlant = {}

autoSeedDropdown = AutoPlant:AddDropdown("SelectSeedsToPlant", {
    Title = "Select Seeds to Plant",
    Description = "These will be planted in available plots.",
    Values = allSeedNames,
    Multi = true,
    Default = {},
    Callback = function(selected)
        selectedSeedsToPlant = {}
        for seedName, isSelected in pairs(selected) do
            if isSelected then
                table.insert(selectedSeedsToPlant, seedName)
            end
        end
    end
})

-- Add Auto Plant toggle
local autoPlantEnabled = false
local autoPlantCoroutine = nil

AutoPlant:AddToggle("AutoPlant", {
    Title = "Auto Plant Seeds",
    Description = "Automatically plant selected seeds in available plots.",
    Default = false,
    Callback = function(enabled)
        autoPlantEnabled = enabled

        if enabled then
            autoPlantCoroutine = task.spawn(function()
                while autoPlantEnabled do
                    -- Get available seeds
                    local seeds = BackpackController:get(BackpackCategory.Seeds)
                    
                    -- Get plant data for all plots
                    local plantsData = DataController:GetValue({ "GardenPlots", "Plants" }) or {}
                    local purchasedPlots = DataController:GetValue({ "GardenPlots", "Purchased" }) or {}
                    
                    -- Find plots with less than 10 plants
                    local availablePlots = {}
                    for plotName, _ in pairs(purchasedPlots) do
                        local plotPlants = plantsData[plotName]
                        local count = 0
                        if type(plotPlants) == "table" then
                            for _, _ in pairs(plotPlants) do
                                count = count + 1
                            end
                        end
                        if count < 10 then
                            table.insert(availablePlots, {name = plotName, count = count})
                        end
                    end
                    
                    -- Sort plots by plant count (ascending)
                    table.sort(availablePlots, function(a, b)
                        return a.count < b.count
                    end)
                    
                    -- Try to plant selected seeds in available plots
                    local planted = false
                    
                    if #availablePlots > 0 then
                        for _, seedName in ipairs(selectedSeedsToPlant) do
                            if seeds[seedName] and seeds[seedName] > 0 then
                                for _, plot in ipairs(availablePlots) do
                                    
                                    local args = {
                                        [1] = plot.name,
                                        [2] = seedName,
                                        [3] = {
                                            [1] = 1,
                                            [2] = 1
                                        }
                                    }
                                    
                                    pcall(function()
                                        PlantService.RF.plant:InvokeServer(unpack(args))
                                    end)
                                    
                                    planted = true
                                    task.wait(0.5)
                                    break -- Move to next seed after successful planting
                                end
                            end
                        end
                    end
                    
                    if not planted then
                        task.wait(5) 
                    else
                        task.wait(1) 
                    end
                end
            end)
        else
            if autoPlantCoroutine then
                task.cancel(autoPlantCoroutine)
                autoPlantCoroutine = nil
            end
        end
    end
})

AutoHarvest = Tabs.Plant:AddSection("Auto Harvest")

local PlotData = require(ReplicatedStorage.Shared.Balancing.Shared.Crafting.PlotData)

-- Build dropdown values from all plot names
local allPlotNames = {}
for plotName, _ in pairs(PlotData.Plots) do
    table.insert(allPlotNames, plotName)
end
table.sort(allPlotNames)

local selectedPlotsToHarvest = {}

noteplot = AutoHarvest:AddParagraph("Note", {
    Title = "Note",
    Content = "The plots won't visually show as harvested until you rejoin, but you will still gain the items and continue to be able to plant.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

plotDropdown = AutoHarvest:AddDropdown("SelectPlotsToHarvest", {
    Title = "Select Plots to Auto Harvest",
    Description = "Choose plots to auto harvest (multi-select).",
    Values = allPlotNames,
    Multi = true,
    Default = {},
    Callback = function(selected)
        selectedPlotsToHarvest = selected or {}
    end
})

local autoHarvestEnabled = false
local autoHarvestCoroutine = nil

AutoHarvest:AddToggle("AutoHarvest", {
    Title = "Auto Harvest",
    Description = "Automatically harvests the selected plots.",
    Default = false,
    Callback = function(enabled)
        autoHarvestEnabled = enabled

        if enabled then
            autoHarvestCoroutine = task.spawn(function()
                while autoHarvestEnabled do
                    for plotName, isSelected in pairs(selectedPlotsToHarvest) do
                        if isSelected then
                            local args = { [1] = plotName }
                            pcall(function()
                                PlotService.RF.harvest:InvokeServer(unpack(args))
                            end)
                            task.wait(0.5)
                        end
                    end
                    task.wait(2)
                end
            end)
        else
            if autoHarvestCoroutine then
                                task.cancel(autoHarvestCoroutine)
                autoHarvestCoroutine = nil
            end
        end
    end
})

-- Auto Buy Seeds Section
AutoBuySeeds = Tabs.Plant:AddSection("Auto Buy Seeds")

local seedDropdownValues = {}
for seedName, _ in pairs(SeedData) do
    seedDropdownValues[seedName] = seedName
end

local selectedSeedToBuy = nil
local seedPurchaseAmount = 1
local autoBuySeedsEnabled = false
local autoBuySeedsCoroutine = nil

AutoBuySeeds:AddDropdown("SelectSeedToBuy", {
    Title = "Select Seed",
    Description = "Choose which seed to purchase.",
    Values = seedDropdownValues,
    Multi = false,
    Default = next(seedDropdownValues),
    Callback = function(selected)
        selectedSeedToBuy = selected
    end
})

AutoBuySeeds:AddInput("SeedPurchaseAmount", {
    Title = "Purchase Amount",
    Description = "The number of seeds you wish\nto buy.",
    Placeholder = "1",
    Numeric = true,
    Default = "1",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            seedPurchaseAmount = math.floor(num)
        else
            seedPurchaseAmount = 1
        end
    end
})

-- Button to Buy Seeds a Fixed Number of Times
AutoBuySeeds:AddButton({
    Title = "Buy Selected Seeds",
    Description = "Purchases the selected seed the chosen number of times.",
    Callback = function()
        if not selectedSeedToBuy then
            return
        end

        autoBuySeedsEnabled = true

        autoBuySeedsCoroutine = task.spawn(function()
            for i = 1, seedPurchaseAmount do
                if not autoBuySeedsEnabled then
                    break
                end

                pcall(function()
                    ReplicatedStorage.Shared.Packages.Knit.Services.SeedStoreService.RF.purchase:InvokeServer(selectedSeedToBuy)
                end)
                task.wait(0.5)
            end

            autoBuySeedsEnabled = false
            autoBuySeedsCoroutine = nil
        end)
    end
})

-- Emergency Stop for Auto Buy Seeds
AutoBuySeeds:AddButton({
    Title = "Emergency Stop Buying",
    Description = "Force stops seed purchases instantly.",
    Callback = function()
        autoBuySeedsEnabled = false
        if autoBuySeedsCoroutine then
            task.cancel(autoBuySeedsCoroutine)
            autoBuySeedsCoroutine = nil
        end
    end
})

-- === POTION SECTION ===
AutoPotionSection = Tabs.Potion:AddSection("Potion Crafting")

local PotionController = Knit.GetController("PotionController")
local UpgradeTreeController = require(LocalPlayer.PlayerScripts.Client.Controllers.Shared.Core.UpgradeTree.UpgradeTreeController)
local RomanModule = require(ReplicatedStorage.Shared.Vendor.RomanModule)
local Potions = require(ReplicatedStorage.Shared.Balancing.Shared.Items.Potions)
local PotionTypes = require(ReplicatedStorage.Shared.Enums.PotionTypes)
local UpgradeTreeTypes = require(ReplicatedStorage.Shared.Enums.UpgradeTreeTypes)

-- Check for tier unlocks
local tier3Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node116)
local tier4Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node117)

-- Create mappings between display names, IDs, and enum keys
local displayNameToEnumKey = {}
local enumKeyToDisplayName = {}
local idToEnumKey = {}

-- Build the mapping tables
for enumKey, potionId in pairs(PotionTypes) do
    local potionData = Potions[potionId]
    if potionData and potionData.Name then
        displayNameToEnumKey[potionData.Name] = enumKey
        enumKeyToDisplayName[enumKey] = potionData.Name
        idToEnumKey[potionId] = enumKey
    end
end

-- Format potion name with tier and enum key
local function formatPotionName(potionId, tier, includeEnumKey)
    local potion = Potions[potionId]
    local name = potion and potion.Name or potionId
    local enumKey = idToEnumKey[potionId] or "Unknown"
    
    local tierNum = tonumber(tier) or 1
    local romanTier = RomanModule.NumberToRoman(tierNum)
    
    if includeEnumKey then
        return string.format("%s (%s) %s", enumKey, name, romanTier)
    else
        return string.format("%s %s", name, romanTier)
    end
end

-- Convert Roman numeral to number
local function romanToNumber(roman)
    if roman == "I" then return 1 end
    if roman == "II" then return 2 end
    if roman == "III" then return 3 end
    if roman == "IV" then return 4 end
    if roman == "V" then return 5 end
    return 1
end

-- Get potion ID and tier from dropdown name string
local function getPotionIdFromName(fullName)
    local enumKey, displayName, roman = fullName:match("^([%w_]+)%s+%((.+)%)%s+([IVX]+)$")
    
    if not enumKey then
        displayName, roman = fullName:match("(.+) ([IVX]+)$")
        if displayName then
            enumKey = displayNameToEnumKey[displayName]
        end
    end
    
    if not roman or (not enumKey and not displayName) then
        return nil, nil
    end
    
    local tier = romanToNumber(roman)
    
    if enumKey and PotionTypes[enumKey] then
        return PotionTypes[enumKey], tier
    end
    
    if displayName then
        local mappedEnumKey = displayNameToEnumKey[displayName]
        if mappedEnumKey and PotionTypes[mappedEnumKey] then
            return PotionTypes[mappedEnumKey], tier
        end
    end
    
    if displayName then
        for potionId, potionData in pairs(Potions) do
            if potionData.Name == displayName then
                return potionId, tier
            end
        end
    end
    
    return nil, nil
end

-- Create sorted list of potions with their data for dropdown
local function getPotionsList()
    local allPotions = {}
    local storage = PotionController.Storage or {}

    for potionId, tiers in pairs(storage) do
        local displayData = idToEnumKey[potionId] and {
            enumKey = idToEnumKey[potionId],
            realName = Potions[potionId] and Potions[potionId].Name or "Unknown"
        } or { 
            enumKey = tostring(potionId), 
            realName = (Potions[potionId] and Potions[potionId].Name) or "Unknown" 
        }

        for tier, amount in pairs(tiers) do
            if typeof(tier) == "string" then
                tier = tonumber(tier) or tier
            end
            if amount and amount > 0 then
                local name = string.format("%s (%s) %s", 
                    displayData.enumKey,
                    displayData.realName,
                    tonumber(tier) and RomanModule.NumberToRoman(tier) or tostring(tier)
                )
                table.insert(allPotions, {
                    name = name,
                    id = potionId,
                    tier = tier,
                    amount = amount,
                    enumKey = displayData.enumKey,
                    realName = displayData.realName,
                    sortKey = string.lower(displayData.enumKey) .. (tonumber(tier) and string.format("%03d", tier) or tostring(tier))
                })
            end
        end
    end

    table.sort(allPotions, function(a, b)
        if a.enumKey == b.enumKey then
            local aTier = tonumber(a.tier) or 0
            local bTier = tonumber(b.tier) or 0
            return aTier < bTier
        end
        return a.enumKey < b.enumKey
    end)

    return allPotions
end

local function getPotionNames()
    local potions = getPotionsList()
    local names = {}
    for _, potion in ipairs(potions) do
        table.insert(names, potion.name)
    end
    return names
end

-- Selected potions and craft amount vars
local selectedPotions = {}
local craftAmount = 1

-- Add potion info paragraph
potionInfoParagraph = AutoPotionSection:AddParagraph("PotionInfo", {
    Title = "Potion Crafting Info",
    Content = "Select potions to see crafting information",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local function updatePotionInfo(selectedPotions)
    if not selectedPotions or not next(selectedPotions) then
        potionInfoParagraph:SetValue("Select potions to see crafting information")
        return
    end

    local infoText = ""

    for potionName, isSelected in pairs(selectedPotions) do
        if isSelected then
            local potionId, tier = getPotionIdFromName(potionName)
            if not potionId then
                infoText = infoText .. "Unable to find data for " .. potionName .. "\n\n"
            else
                local amount = 0
                local storage = PotionController.Storage or {}
                amount = storage[potionId] and (storage[potionId][tier] or storage[potionId][tostring(tier)]) or 0

                local maxCraftable = math.floor(amount / 4)
                local canCraft = maxCraftable >= 1

                local nextTier = tonumber(tier) and tier + 1 or 2
                local tierUnlocked = true
                if nextTier == 4 and not tier3Unlocked then
                    tierUnlocked = false
                elseif nextTier == 5 and not tier4Unlocked then
                    tierUnlocked = false
                elseif nextTier > 5 then
                    tierUnlocked = false
                end

                infoText = infoText .. potionName .. ":\n"
                infoText = infoText .. " Current amount: " .. amount .. "\n"
                infoText = infoText .. " Can craft: " .. (canCraft and "Yes" or "No") .. "\n"
                infoText = infoText .. " Max craftable: " .. maxCraftable .. "\n"
                infoText = infoText .. " Crafting available: " .. (tierUnlocked and "Yes" or "No. You won't be able to craft this tier with your current upgrades.") .. "\n"
            end
        end
    end

    potionInfoParagraph:SetValue(infoText ~= "" and infoText or "No valid potions selected")
end

-- Add potion dropdown (multi-select)
potionDropdown = AutoPotionSection:AddDropdown("PotionSelect", {
    Title = "Select Potions",
    Description = "Choose which potions to craft (multi-select)",
    Values = getPotionNames(),
    Multi = true,
    Default = {},
    Callback = function(value)
        selectedPotions = value
        updatePotionInfo(value)
    end
})

-- Add craft amount input
craftAmountInput = AutoPotionSection:AddInput("CraftAmount", {
    Title = "Craft Amount",
    Description = "Number of potions to craft",
    Placeholder = "--",
    Numeric = true,
    Default = "",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            craftAmount = math.floor(num * 4)
        else
            craftAmount = 4
        end
    end
})

-- Craft selected potions button
AutoPotionSection:AddButton({
    Title = "Craft Selected Potions",
    Description = "Craft the selected amount of each selected potion",
    Callback = function()
        if not next(selectedPotions) then return end
        
        for potionName, isSelected in pairs(selectedPotions) do
            if isSelected then
                local potionId, tier = getPotionIdFromName(potionName)
                if potionId and tier then
                    local args = {potionId, tier, craftAmount}
                    pcall(function()
                        ReplicatedStorage.Shared.Packages.Knit.Services.PotionUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                    end)
                    task.wait(0.2)
                end
            end
        end
        
        task.wait(0.5)
        updatePotionInfo(selectedPotions)
    end
})

AutoPotionSection:AddButton{
    Title = "Craft All",
    Description = "Craft all your selected potions.",
    Callback = function()
        if not next(selectedPotions) then return end

        local storage = PotionController.Storage or {}
        local potionsToCraft = {}

        for potionName, isSelected in pairs(selectedPotions) do
            if isSelected then
                local potionId, tier = getPotionIdFromName(potionName)
                if potionId and tier then
                    local amount = (storage[potionId] and (storage[potionId][tier] or storage[potionId][tostring(tier)])) or 0
                    if amount > 0 then
                        table.insert(potionsToCraft, {
                            id = potionId,
                            tier = tier,
                            amount = amount,
                            name = potionName
                        })
                    end
                end
            end
        end

        if #potionsToCraft == 0 then return end

        Window:Dialog{
            Title = "Confirm Crafting",
            Content = "Are you sure you want to craft all of your selected potions?", 
            Buttons = {
                {
                    Title = "Confirm",
                    Callback = function()
                        for _, potion in ipairs(potionsToCraft) do
                            local args = {potion.id, potion.tier, potion.amount}
                            pcall(function()
                                ReplicatedStorage.Shared.Packages.Knit.Services.PotionUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                            end)
                            task.wait(0.2)
                        end
                        task.wait(0.5)
                        updatePotionInfo(selectedPotions)
                    end
                },
                {
                    Title = "Cancel",
                    Callback = function()
                    end
                }
            }
        }
    end
}

-- Active Potions Section
ActivePotionsSection = Tabs.Potion:AddSection("Active Potions")

activePotionsParagraph = ActivePotionsSection:AddParagraph("ActivePotions", {
    Title = "Current Active Potions",
    Content = "Loading...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local function updateActivePotions()
    local activeList = {}

    if PotionController.Active then
        for potionId, tiers in pairs(PotionController.Active) do
            for tier, duration in pairs(tiers) do
                if typeof(tier) == "string" then
                    tier = tonumber(tier) or tier
                end
                
                if duration and duration > 0 then
                    local displayData = idToEnumKey[potionId] and {
                        enumKey = idToEnumKey[potionId],
                        realName = Potions[potionId] and Potions[potionId].Name or "Unknown"
                    } or {
                        enumKey = tostring(potionId),
                        realName = (Potions[potionId] and Potions[potionId].Name) or "Unknown"
                    }

                    local name = string.format("%s (%s) %s",
                        displayData.enumKey,
                        displayData.realName,
                        tonumber(tier) and RomanModule.NumberToRoman(tier) or tostring(tier)
                    )

                    table.insert(activeList, {
                        name = name,
                        duration = duration,
                        sortKey = string.lower(displayData.enumKey) .. (tonumber(tier) and string.format("%03d", tier) or tostring(tier))
                    })
                end
            end
        end
    end

    table.sort(activeList, function(a, b)
        return a.sortKey < b.sortKey
    end)

    local activeText = ""
    if #activeList == 0 then
        activeText = "No active potions"
    else
        for _, potion in ipairs(activeList) do
            activeText = activeText .. potion.name .. ": " .. math.floor(potion.duration) .. "s remaining\n"
        end
    end

    activePotionsParagraph:SetValue(activeText)
end

updateActivePotions()

task.spawn(function()
    while true do
        task.wait(15)
        updateActivePotions()
    end
end)

-- === ENCHANTMENT SECTION ===
AutoEnchantSection = Tabs.Enchant:AddSection("Enchantment Crafting")

local EnchantmentController = Knit.GetController("EnchantmentController")
local Enchantments = require(ReplicatedStorage.Shared.Balancing.Shared.Items.Enchantments)
local EnchantmentTypes = require(ReplicatedStorage.Shared.Enums.EnchantmentTypes)
local enchant4Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node128)
local enchant5Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node129)

-- Create mappings (similar to potions)
local displayNameToEnumKey = {}
local enumKeyToDisplayName = {}
local idToEnumKey = {}

for enumKey, enchantId in pairs(EnchantmentTypes) do
    local enchantData = Enchantments[enchantId]
    if enchantData and enchantData.Name then
        displayNameToEnumKey[enchantData.Name] = enumKey
        enumKeyToDisplayName[enumKey] = enchantData.Name
        idToEnumKey[enchantId] = enumKey
    end
end

-- Get enchantment ID and tier from dropdown name string
local function getEnchantIdFromName(fullName)
    local enumKey, displayName, roman = fullName:match("^([%w_]+)%s+%((.+)%)%s+([IVX]+)$")
    
    if not enumKey then
        displayName, roman = fullName:match("(.+) ([IVX]+)$")
        if displayName then
            enumKey = displayNameToEnumKey[displayName]
        end
    end
    
    if not roman or (not enumKey and not displayName) then
        return nil, nil
    end
    
    local tier = romanToNumber(roman)
    
    if enumKey and EnchantmentTypes[enumKey] then
        return EnchantmentTypes[enumKey], tier
    end
    
    if displayName then
        local mappedEnumKey = displayNameToEnumKey[displayName]
        if mappedEnumKey and EnchantmentTypes[mappedEnumKey] then
            return EnchantmentTypes[mappedEnumKey], tier
        end
    end
    
    if displayName then
        for enchantId, enchantData in pairs(Enchantments) do
            if enchantData.Name == displayName then
                return enchantId, tier
            end
        end
    end
    
    return nil, nil
end

local function getEnchantmentsList()
    local allEnchantments = {}
    local storage = EnchantmentController.Storage or {}

    for enchantId, tiers in pairs(storage) do
        local displayData = idToEnumKey[enchantId] and {
            enumKey = idToEnumKey[enchantId],
            realName = Enchantments[enchantId] and Enchantments[enchantId].Name or "Unknown"
        } or { 
            enumKey = tostring(enchantId), 
            realName = (Enchantments[enchantId] and Enchantments[enchantId].Name) or "Unknown" 
        }

        for tier, amount in pairs(tiers) do
            if typeof(tier) == "string" then
                tier = tonumber(tier) or tier
            end
            if amount and amount > 0 then
                local name = string.format("%s (%s) %s", 
                    displayData.enumKey,
                    displayData.realName,
                    tonumber(tier) and RomanModule.NumberToRoman(tier) or tostring(tier)
                )
                table.insert(allEnchantments, {
                    name = name,
                    id = enchantId,
                    tier = tier,
                    amount = amount,
                    enumKey = displayData.enumKey,
                    realName = displayData.realName,
                    sortKey = string.lower(displayData.enumKey) .. (tonumber(tier) and string.format("%03d", tier) or tostring(tier))
                })
            end
        end
    end

    table.sort(allEnchantments, function(a, b)
        if a.enumKey == b.enumKey then
            local aTier = tonumber(a.tier) or 0
            local bTier = tonumber(b.tier) or 0
            return aTier < bTier
        end
        return a.enumKey < b.enumKey
    end)

    return allEnchantments
end

local function getEnchantmentNames()
    local enchants = getEnchantmentsList()
    local names = {}
    for _, enchant in ipairs(enchants) do
        table.insert(names, enchant.name)
    end
    return names
end

local selectedEnchantments = {}
craftAmount = 1

enchantInfoParagraph = AutoEnchantSection:AddParagraph("EnchantInfo", {
    Title = "Enchantment Crafting Info",
    Content = "Select enchantments to see crafting information",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local function updateEnchantInfo(selectedEnchantments)
    if not selectedEnchantments or not next(selectedEnchantments) then
        enchantInfoParagraph:SetValue("Select enchantments to see crafting information")
        return
    end

    local infoText = ""

    for enchantName, isSelected in pairs(selectedEnchantments) do
        if isSelected then
            local enchantId, tier = getEnchantIdFromName(enchantName)
            if not enchantId then
                infoText = infoText .. "Unable to find data for " .. enchantName .. "\n\n"
            else
                local amount = 0
                local storage = EnchantmentController.Storage or {}
                amount = storage[enchantId] and (storage[enchantId][tier] or storage[enchantId][tostring(tier)]) or 0

                local maxCraftable = math.floor(amount / 5)
                local canCraft = maxCraftable >= 1

                local nextTier = tonumber(tier) and tier + 1 or 2
                local tierUnlocked = true
                if nextTier == 4 and not enchant4Unlocked then
                    tierUnlocked = false
                elseif nextTier == 5 and not enchant5Unlocked then
                    tierUnlocked = false
                elseif nextTier > 5 then
                    tierUnlocked = false
                end

                infoText = infoText .. enchantName .. ":\n"
                infoText = infoText .. " Current amount: " .. amount .. "\n"
                infoText = infoText .. " Can craft: " .. (canCraft and "Yes" or "No") .. "\n"
                infoText = infoText .. " Max craftable: " .. maxCraftable .. "\n"
                infoText = infoText .. " Crafting available: " .. (tierUnlocked and "Yes" or "No. You won't be able to craft this tier with your current upgrades.") .. "\n"
            end
        end
    end

    enchantInfoParagraph:SetValue(infoText ~= "" and infoText or "No valid enchantments selected")
end

enchantDropdown = AutoEnchantSection:AddDropdown("EnchantSelect", {
    Title = "Select Enchantments",
    Description = "Choose which enchantments to craft (multi-select)",
    Values = getEnchantmentNames(),
    Multi = true,
    Default = {},
    Callback = function(value)
        selectedEnchantments = value
        updateEnchantInfo(value)
    end
})

craftAmountInput = AutoEnchantSection:AddInput("EnchantCraftAmount", {
    Title = "Craft Amount",
    Description = "Number of enchants to upgrade",
    Placeholder = "--",
    Numeric = true,
    Default = "",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            craftAmount = math.floor(num * 5)
        else
            craftAmount = 5
        end
    end
})

AutoEnchantSection:AddButton({
    Title = "Craft Selected Enchantments",
    Description = "Craft the selected amount of each selected enchantment",
    Callback = function()
        if not next(selectedEnchantments) then return end
        
        for enchantName, isSelected in pairs(selectedEnchantments) do
            if isSelected then
                local enchantId, tier = getEnchantIdFromName(enchantName)
                if enchantId and tier then
                    local args = {enchantId, tier, craftAmount}
                    pcall(function()
                        ReplicatedStorage.Shared.Packages.Knit.Services.EnchantmentUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                    end)
                    task.wait(0.2)
                end
            end
        end
        
        task.wait(0.5)
        updateEnchantInfo(selectedEnchantments)
    end
})

AutoEnchantSection:AddButton({
    Title = "Craft All",
    Description = "Craft all your selected enchantments.",
    Callback = function()
        if not next(selectedEnchantments) then return end

        local storage = EnchantmentController.Storage or {}
        local enchantsToCraft = {}

        for enchantName, isSelected in pairs(selectedEnchantments) do
            if isSelected then
                local enchantId, tier = getEnchantIdFromName(enchantName)
                if enchantId and tier then
                    local amount = (storage[enchantId] and (storage[enchantId][tier] or storage[enchantId][tostring(tier)])) or 0
                    if amount > 0 then
                        table.insert(enchantsToCraft, {
                            id = enchantId,
                            tier = tier,
                            amount = amount,
                            name = enchantName
                        })
                    end
                end
            end
        end

        if #enchantsToCraft == 0 then return end

        Window:Dialog({
            Title = "Confirm Crafting",
            Content = "Are you sure you want to craft all of your selected enchantments?", 
            Buttons = {
                {
                    Title = "Confirm",
                    Callback = function()
                        for _, enchant in ipairs(enchantsToCraft) do
                            local args = {enchant.id, enchant.tier, enchant.amount}
                            pcall(function()
                                ReplicatedStorage.Shared.Packages.Knit.Services.EnchantmentUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                            end)
                            task.wait(0.2)
                        end
                        task.wait(0.5)
                        updateEnchantInfo(selectedEnchantments)
                    end
                },
                {
                    Title = "Cancel",
                    Callback = function()
                    end
                }
            }
        })
    end
})



-- === MINIGAMES SECTION ===
local minigameKeys = 0

minigameStatus = Tabs.Minigames:AddParagraph("MinigameKeys", {
    Title = "Minigame Keys",
    Content = "Loading minigame key count...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local function updateMinigameKeyCount()
    local function getCurrencyAmount(category, currencyType)
        if BackpackController and BackpackController.get then
            return BackpackController:get(category, currencyType) or 0
        end
        return 0
    end
    
    minigameKeys = getCurrencyAmount(BackpackCategory.BackpackCurrency, BackpackCurrencyTypes.MinigameKey)
    minigameStatus:SetValue(" Minigame Keys: " .. minigameKeys)
end

updateMinigameKeyCount()

task.spawn(function()
    while true do
        task.wait(5)
        updateMinigameKeyCount()
    end
end)

ObbySection = Tabs.Minigames:AddSection("Parkour Obby")

local autoObbyEnabled = false
local autoObbyConnection = nil

ObbySection:AddToggle("AutoObby", {
    Title = "Auto Complete Obby",
    Description = "Automatically completes the parkour Obby. If you get stuck when you turn this toggle off, respawn.",
    Default = false,
    Callback = function(enabled)
        autoObbyEnabled = enabled

        if enabled and minigameKeys > 0 then
            if autoObbyConnection then task.cancel(autoObbyConnection) end

            autoObbyConnection = task.spawn(function()
                local LocalPlayer = game:GetService("Players").LocalPlayer
                local ReplicatedStorage = game:GetService("ReplicatedStorage")

                while autoObbyEnabled do
                    -- Enter the Obby (safe call)
                    pcall(function()
                        ReplicatedStorage.Shared.Packages.Knit.Services.ObbyService.RF.enter:InvokeServer("OBBY_W2Z3")
                    end)

                    -- Fire the TouchInterest directly
                    local endPart = workspace:FindFirstChild("Obby") 
                        and workspace.Obby:FindFirstChild("OBBY_W2Z3") 
                        and workspace.Obby.OBBY_W2Z3:FindFirstChild("Important") 
                        and workspace.Obby.OBBY_W2Z3.Important:FindFirstChild("End")

                    if endPart and endPart:FindFirstChild("TouchInterest") then
                        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        if hrp then
                            firetouchinterest(hrp, endPart, 0) -- touch began
                            firetouchinterest(hrp, endPart, 1) -- touch ended
                        end
                    end

                    task.wait(0.5)
                end
            end)
        else
            if autoObbyConnection then
                task.cancel(autoObbyConnection)
                autoObbyConnection = nil
            end
        end
    end
})

local minigamesTab = Tabs.Minigames:AddSection("Circus")
local CircusService = Knit.GetService("CircusService")
local CircusController = require(LocalPlayer.PlayerScripts.Client.Controllers.Normal.Minigames.Circus.CircusController)

local autoCircusEnabled = false
local autoCircusConnection = nil

-- Leave circus function
local function leaveCircus()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
    local GetUI = require(ReplicatedStorage.Shared.Vendor.GetUI)
    local UIModule = require(ReplicatedStorage.Shared.Vendor.UIModule)
    local workspace = game:GetService("Workspace")

    local CircusService = Knit.GetService("CircusService")
    local carnivalWinScreen = GetUI({"GameUI", "HUDS", "Circus", "CarnivalWinScreen"})
    CircusService:claim():andThen(function(success)
        if success then
            workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
            UIModule.SetHud()
        end
    end)
end

-- Function to open a random barrel
local function openRandomBarrel()
    if not CircusController.Active then return end
    if CircusController.Current == 31 then return end -- Don't open or progress if room is 31

    local barrels = CircusController:getBarrels()
    local barrelNames = {}
    for name, _ in pairs(barrels) do
        table.insert(barrelNames, name)
    end

    if #barrelNames == 0 then return end

    local randomIndex = math.random(1, #barrelNames)
    local randomBarrelName = barrelNames[randomIndex]

    CircusService:open(randomBarrelName):andThen(function(success, rewards, failed, attemptsLeft)
        if not success then
            return
        end
        for name, barrel in pairs(barrels) do
            if name == randomBarrelName then
                CircusController:explode(barrel, rewards[name], true)
            else
                task.delay(1.25, function()
                    CircusController:explode(barrel, rewards[name])
                end)
            end
        end
        task.wait(1)
        
        -- Fire the click event instead of waiting for it
        CircusController.OnClick:Fire()
        
        -- Only progress if not in room 31
        if CircusController.Current ~= 31 then
            CircusController:moveToNext(false)
        end
    end)
end

-- Connect to the OnClick event
CircusController.OnClick:Connect(openRandomBarrel)

-- Toggle for auto play
minigamesTab:AddToggle("AutoCircusMinigame", {
    Title = "Auto Circus Minigame",
    Description = "Automatically complete the Circus minigame.",
    Default = false,
    Callback = function(enabled)
        autoCircusEnabled = enabled

        if enabled then
            -- Loop for firing Enter every 5 seconds
            autoCircusEnterConnection = task.spawn(function()
                while autoCircusEnabled do
                    ReplicatedStorage.Shared.Packages.Knit.Services.CircusService.RE.Enter:FireServer()
                    task.wait(5)
                end
            end)

            -- Loop for clicking every 1 second if Circus is active
            autoCircusClickConnection = task.spawn(function()
                while autoCircusEnabled do
                    if CircusController.Active then
                        if CircusController.Current == 31 then
                            leaveCircus()
                            repeat task.wait(1) until not CircusController.Active
                        else
                            CircusController.OnClick:Fire()
                        end
                    end
                    task.wait(1)
                end
            end)
        else
            -- Stop both loops
            if autoCircusEnterConnection then
                task.cancel(autoCircusEnterConnection)
                autoCircusEnterConnection = nil
            end
            if autoCircusClickConnection then
                task.cancel(autoCircusClickConnection)
                autoCircusClickConnection = nil
            end
        end
    end
})


local Mining = Tabs.Minigames:AddSection("Mining Minigame")

Mining:AddButton({
    Title = "Mining Script",
    Description = "Loads my Mining script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/mining/refs/heads/main/petwarriors"))()
    end
})

-- === GIFTS SECTION ===
AutoClaimSection = Tabs.Gifts:AddSection("Auto Claim")

local autoClaimEnabled = false
local autoClaimConnection = nil

AutoClaimSection:AddToggle("AutoClaimGifts", {
    Title = "Auto Claim Gifts",
    Description = "Automatically claim availble gifts (won't visually show as claimed until you rejoin).",
    Default = false,
    Callback = function(enabled)
        autoClaimEnabled = enabled

        if enabled then
            autoClaimConnection = task.spawn(function()
                while autoClaimEnabled do
                    for i = 1, 12 do
                        local args = { i }
                        pcall(function()
                            ReplicatedStorage.Shared.Packages.Knit.Services.TimedRewardsService.RF.claim:InvokeServer(unpack(args))
                        end)
                        task.wait(0.5)
                    end
                    task.wait(20)
                end
            end)
        else
            if autoClaimConnection then
                task.cancel(autoClaimConnection)
                autoClaimConnection = nil
            end
        end
    end
})

AutoClaimSection:AddToggle("AutoDailyDaily", {
    Title = "Auto Claim Daily Rewards",
    Description = "Automatically claim daily rewards (won't visually show as claimed until you rejoin).",
    Default = false,
    Callback = function(enabled)
        AutoDailyEnabled = enabled

        if enabled then
            AutoDailyConnection = task.spawn(function()
                while AutoDailyEnabled do
                    for i = 1, 7 do
                        local args = { i }
                        pcall(function()
                            ReplicatedStorage.Shared.Packages.Knit.Services.DailyService.RF.claim:InvokeServer(unpack(args))
                        end)
                        task.wait(1)
                    end
                    task.wait(30)
                end
            end)
        else
            if AutoDailyConnection then
                task.cancel(AutoDailyConnection)
                AutoDailyConnection = nil
            end
        end
    end
})

AutoClaimSection:AddToggle("AutoChest", {
    Title = "Auto Claim Group Chest",
    Description = "Automatically claim available chests (won't visually show as claimed until you rejoin).",
    Default = false,
    Callback = function(enabled)
        autoChestEnabled = enabled

        if enabled then
            autoChestConnection = task.spawn(function()
                while autoChestEnabled do
                    -- Loop through all chests dynamically
                    for _, world in pairs(workspace.Core_Game.Chests:GetChildren()) do
                        for _, group in pairs(world:GetChildren()) do
                            local hitbox = group:FindFirstChild("Hitbox")
                            if hitbox then
                                local textLabel = hitbox.Attachment.Billboard.Frame:FindFirstChild("TextLow")
                                if textLabel and not textLabel.Text:match("%d") then
                                    -- Fire the touch to claim
                                    pcall(function()
                                        local hrp = game.Players.LocalPlayer.Character.HumanoidRootPart
                                        firetouchinterest(hrp, hitbox, 0)
                                        firetouchinterest(hrp, hitbox, 1)
                                    end)
                                end
                            end
                        end
                    end
                    task.wait(1) -- check every second
                end
            end)
        else
            if autoChestConnection then
                task.cancel(autoChestConnection)
                autoChestConnection = nil
            end
        end
    end
})


local VendingMachines = require(ReplicatedStorage.Shared.Balancing.Shared.VendingMachines)


local vendingMachineService = Knit.GetService("VendingMachineService")

-- Build vending machine dropdown
local vendingNames = {}
local vendingKeyMap = {}

for vendingKey, config in pairs(VendingMachines) do
    local world = config.World or "World?"
    local zone = config.Zone or "Zone?"
    local displayName = tostring(world) .. "_Zone" .. tostring(zone)
    table.insert(vendingNames, displayName)
    vendingKeyMap[displayName] = vendingKey
end

table.sort(vendingNames)

local selectedVending = {}
local vendingLoops = {}

-- Dropdown
vending = Tabs.Gifts:AddSection("Vending Machines")

vendingDropdown = vending:AddDropdown("VendingSelect", {
    Title = "Select Vending Machine",
    Description = "Choose vending machines to auto buy from.",
    Values = vendingNames,
    Multi = true,
    Default = {},
    Callback = function(selected)
        selectedVending = selected or {}
    end
})

-- Safe stock fetch
local function getStock(data)
    local stock = 0
    if typeof(data) == "number" then
        stock = data
    elseif typeof(data) == "table" and data.Stock then
        if typeof(data.Stock) == "number" then
            stock = data.Stock
        elseif typeof(data.Stock) == "table" then
            for _, amt in pairs(data.Stock) do
                if type(amt) == "number" then
                    stock = stock + amt
                end
            end
        end
    end
    return stock
end

-- Safe buy
local function buyFromMachine(vendingKey, displayName)
    vendingMachineService:open(vendingKey):andThen(function(success, data)
        if not success or typeof(data) ~= "table" then
            return
        end

        local stock = getStock(data)
        if stock > 0 then
            pcall(function()
                ReplicatedStorage.Shared.Packages.Knit.Services.VendingMachineService.RF.purchase:InvokeServer(vendingKey)
            end)
        end
    end)
end

-- Auto-buy toggle
local autoBuyEnabled = false
vendingToggle = vending:AddToggle("AutoBuyVending", {
    Title = "Auto Buy",
    Description = "Automatically buys from selected vending machines until stock runs out.",
    Default = false,
    Callback = function(enabled)
        autoBuyEnabled = enabled

        if enabled then
            for vendingName, isSelected in pairs(selectedVending) do
                if isSelected and not vendingLoops[vendingName] then
                    local vendingKey = vendingKeyMap[vendingName]
                    vendingLoops[vendingName] = task.spawn(function()
                        while autoBuyEnabled and selectedVending[vendingName] do
                            buyFromMachine(vendingKey, vendingName)
                            task.wait(1)
                        end
                        vendingLoops[vendingName] = nil
                    end)
                end
            end
        else
            for _, loop in pairs(vendingLoops) do
                task.cancel(loop)
            end
            vendingLoops = {}
        end
    end
})

-- Optional: print all vending machine stock
local function printVendingMachineStock()
    print("==== VENDING MACHINE STOCK ====")
    for vendingKey, config in pairs(VendingMachines) do
        local world = config.World or "World?"
        local zone = config.Zone or "Zone?"
        local displayName = tostring(world) .. "_Zone" .. tostring(zone)
        vendingMachineService:open(vendingKey):andThen(function(success, data)
            local stock = 0
            if success and data then stock = getStock(data) end
            local rewardName = (data and data.Reward and data.Reward.Name) or "Unknown"
        end)
    end
end


-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes{}
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

-- Add Anti-AFK button to Settings tab
local antiafk = Tabs.Settings:AddSection("Anti AFK")

Tabs.Settings:AddButton({
    Title = "Anti AFK",
    Description = "Prevents being kicked from inactivity.",
    Callback = function()
        -- First click immediately
        clickTopRight()

        -- Add periodic clicking (every 5 minutes) to prevent AFK disconnection
        task.spawn(function()
            while true do
                task.wait(300) -- 5 minutes
                clickTopRight()
            end
        end)
    end
})

local usercountsection = Tabs.Settings:AddSection("User Count")

local userCountParagraph = Tabs.Settings:AddParagraph("UserCountStatus", {
    Title = "Script User Count",
    Content = "Loading..."
})

-- Step 1: Register the user
local registerResponse = requestFunc({
    Url = "https://duckyscripts.pythonanywhere.com/api/pet/add-user",
    Method = "POST",
    Headers = {
        ["Content-Type"] = "application/json"
    },
    Body = HttpService:JSONEncode({
        username = username,
        userid = userid
    })
})

-- Optional: handle registration response if needed
if registerResponse and registerResponse.Body then
    local responseData = HttpService:JSONDecode(registerResponse.Body)
    if responseData.success then
        print("Registered user:", username)
    end
end

-- Step 2: Heartbeat loop to set user active and update counts
task.spawn(function()
    while true do
        local heartbeatResponse = requestFunc({
            Url = "https://duckyscripts.pythonanywhere.com/api/pet/active",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = HttpService:JSONEncode({
                userid = userid,
                active = true
            })
        })

        if heartbeatResponse and heartbeatResponse.Body then
            local responseBody = heartbeatResponse.Body
            local data = HttpService:JSONDecode(responseBody)
            
            -- Update the paragraph with current counts
            local activeCount = data.active_count or 0
            local totalCount = data.count or 0
            userCountParagraph:SetValue(
                "Total users: " .. tostring(totalCount) .. "\n" ..
                "Active Users: " .. tostring(activeCount)
            )
        end

        task.wait(30) -- wait 30 seconds between heartbeats
    end
end)



InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()
