-- Pet Warriors 

local Library = loadstring(game:HttpGet("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()

local Window = Library:Window{
    Title = "Pet Warriors",
    SubTitle = "Script Hub",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Resize = false,
    Acrylic = true,
    Theme = "Vynixu",
    MinimizeKey = Enum.KeyCode.LeftShift
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")




local Tabs = {
    AutoFarm = Window:AddTab({ Title = "Main", Icon = "sword" }),
    Eggs = Window:AddTab({ Title = "Hatch", Icon = "egg" }),
    Upgrades = Window:AddTab({ Title = "Upgrades", Icon = "star" }),
    Machines = Window:AddTab({ Title = "Machines", Icon = "cog" }),
    Teleport = Window:AddTab({ Title = "Teleport", Icon = "rocket" }),
    Plant = Window:AddTab({ Title = "Gardening", Icon = "phosphor-plant-bold" }),
    Potion = Window:AddTab({ Title = "Potion Crafting", Icon = "flask-conical" }),
    Enchant = Window:AddTab({ Title = "Enchant Upgrades", Icon = "book-open" }),
    Minigames = Window:AddTab({ Title = "Minigames", Icon = "phosphor-game-controller-light" }),
    Gifts = Window:AddTab({ Title = "Misc", Icon = "gift" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local ReplicatedStorage = game:GetService("ReplicatedStorage")


local AutoCollectSection = Tabs.AutoFarm:AddSection("Auto Train")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
if not Knit.Started then
    Knit.OnStart():await()
end

local BreakableController = require(LocalPlayer.PlayerScripts.Client.Controllers.Normal.Breakables.BreakableController)
local WorldController = Knit.GetController("WorldController")
local ZoneController = Knit.GetController("ZoneController")
local BreakablesEnum = require(ReplicatedStorage.Shared.Enums.Breakables)

-- Optional AFK Module
local AFKModule
pcall(function()
    AFKModule = require(ReplicatedStorage.Shared.Vendor.AFKModule)
end)

-- Collect breakable names for dropdown, exclude hearts with sizes
local breakableNames = {}
local uniqueItems = {}
for enumName, enumId in pairs(BreakablesEnum) do
    local name = enumName:match("^W%d+_Z%d+_(.+)$") or enumName
    local lowerName = name:lower()

    local isHeartSize = (lowerName:find("small") and lowerName:find("hearts")) or
                        (lowerName:find("medium") and lowerName:find("hearts")) or
                        (lowerName:find("large") and lowerName:find("hearts"))
    if not isHeartSize and not uniqueItems[name] then
        uniqueItems[name] = enumId
        table.insert(breakableNames, name)
    end
end
table.sort(breakableNames)

-- UI Paragraph to show priority list
local breakablePriorityParagraph = AutoCollectSection:AddParagraph("BreakablePriority", {
    Title = "Target Priority",
    Content = "No breakables selected",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Breakable priorities storage: name -> priority (lower = higher priority)
local breakablePriorities = {}
local nextPriority = 1

local function updateBreakablePriorityDisplay()
    local prioritized = {}
    for name, priority in pairs(breakablePriorities) do
        table.insert(prioritized, {name = name, priority = priority})
    end
    table.sort(prioritized, function(a,b) return a.priority < b.priority end)

    if #prioritized == 0 then
        breakablePriorityParagraph:SetValue("No breakables selected")
        return
    end

    local text = "Priority order:\n"
    for i, item in ipairs(prioritized) do
        text = text .. i .. ". " .. item.name .. "\n"
    end
    breakablePriorityParagraph:SetValue(text)
end

-- Dropdown for selecting prioritized breakables
local breakableDropdown = AutoCollectSection:AddDropdown("BreakableSelect", {
    Title = "Select what to aim for",
    Description = "Items will be prioritized in the order selected. First = highest priority.",
    Values = breakableNames,
    Multi = true,
    Searchable = true,
    Default = {},
    Callback = function(value)
        -- Track selected breakables
        local currentlySelected = {}
        for name, selected in pairs(value) do
            if selected then
                currentlySelected[name] = true
            end
        end

        -- Remove deselected breakables
        for name in pairs(breakablePriorities) do
            if not currentlySelected[name] then
                breakablePriorities[name] = nil
            end
        end

        -- Add newly selected breakables with incrementing priority
        for name, selected in pairs(value) do
            if selected and not breakablePriorities[name] then
                breakablePriorities[name] = nextPriority
                nextPriority = nextPriority + 1
            end
        end

        updateBreakablePriorityDisplay()
    end
})

-- Get all breakables in current world & zone grouped by name
local function getBreakablesInCurrentZone()
    local currentWorld = WorldController.Current or "World1"
    local worldNumber = tonumber(currentWorld:match("World(%d+)")) or 1
    local currentZone = ZoneController.Current or 1

    local breakableObjectsByName = {}

    if BreakableController.Breakables then
        for _, breakable in pairs(BreakableController.Breakables) do
            local worldNum = tonumber(tostring(breakable.World):match("World(%d+)")) or tonumber(breakable.World) or 1
            local zone = breakable.Zone
            local id = breakable.ID

            if worldNum == worldNumber and zone == currentZone then
                local name = "Unknown"
                for enumName, enumId in pairs(BreakablesEnum) do
                    if enumId == id then
                        name = enumName:match("^W%d+_Z%d+_(.+)$") or enumName
                        break
                    end
                end

                breakableObjectsByName[name] = breakableObjectsByName[name] or {}
                table.insert(breakableObjectsByName[name], breakable)
            end
        end
    end

    return breakableObjectsByName
end

-- Teleport player near breakable
local function teleportToBreakable(breakable)
    if not breakable or not breakable.Position then return false end

    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local offset = Vector3.new(0, 3, 0)
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(breakable.Position + offset)

        if AFKModule then
            pcall(function()
                AFKModule.Set("Breakables")
            end)
        end

        return true
    end
    return false
end

-- Find closest prioritized breakable (lowest distance)
local function findClosestPriorityBreakable()
    local breakableObjects = getBreakablesInCurrentZone()
    if not breakableObjects or not next(breakableObjects) then
        return nil
    end

    local closestBreakable = nil
    local closestDistance = math.huge

    local character = LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local charPos = hrp.Position

    for name, objects in pairs(breakableObjects) do
        if breakablePriorities[name] and #objects > 0 then
            for _, obj in ipairs(objects) do
                local dist = (obj.Position - charPos).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestBreakable = obj
                end
            end
        end
    end

    return closestBreakable
end

-- Attack breakable via Knit service safely
local function attackBreakable()
    pcall(function()
        local BreakableAttackService = ReplicatedStorage.Shared.Packages.Knit.Services.BreakableAttackService
        if BreakableAttackService and BreakableAttackService.RF and BreakableAttackService.RF.attack then
            BreakableAttackService.RF.attack:InvokeServer()
        end
    end)
end

-- Main auto train toggle
local autoTrainEnabled = false
local autoTrainConnection = nil
local currentBreakable = nil

AutoCollectSection:AddToggle("AutoTrainToggle", {
    Title = "Auto Train",
    Description = "Automatically teleport to and attack breakables based on priority",
    Default = false,
    Callback = function(enabled)
        autoTrainEnabled = enabled

        if enabled then
            autoTrainConnection = task.spawn(function()
                while autoTrainEnabled do
                    -- Find closest prioritized breakable
                    local target = findClosestPriorityBreakable()

                    -- Fallback if no priority breakable found
                    if not target then
                        local breakableObjects = getBreakablesInCurrentZone()
                        local sizeKeywords = {"LARGE", "MEDIUM", "SMALL"}

                        local foundFallback = false
                        for _, size in ipairs(sizeKeywords) do
                            for name, objects in pairs(breakableObjects) do
                                if name:upper():find(size) and #objects > 0 then
                                    target = objects[1]
                                    foundFallback = true
                                    break
                                end
                            end
                            if foundFallback then break end
                        end

                        if not foundFallback then
                            for _, objects in pairs(breakableObjects) do
                                if #objects > 0 then
                                    target = objects[1]
                                    break
                                end
                            end
                        end
                    end

                    if target then
                        teleportToBreakable(target)
                    end

                    -- Attack breakable rapidly every 0.001 seconds,
                    -- but teleport/update target every 0.01 seconds in this loop
                    local attackStart = tick()
                    while autoTrainEnabled and tick() - attackStart < 0.01 do
                        attackBreakable()
                        task.wait(0.001)
                    end

                    task.wait(0) -- yield briefly to prevent locking up
                end
            end)
        else
            if autoTrainConnection then
                task.cancel(autoTrainConnection)
                autoTrainConnection = nil
            end
        end
    end
})


-- Initialize the priority display
updateBreakablePriorityDisplay()

-- Add Auto Collect Drops toggle
local autoCollectEnabled = false
local autoCollectCoroutine = nil

AutoCollectSection:AddToggle("AutoCollectDrops", {
    Title = "Auto Collect Drops",
    Description = "Collect Dropped Items/Strength",
    Default = false,
    Callback = function(enabled)
        autoCollectEnabled = enabled

        if enabled then
            autoCollectCoroutine = task.spawn(function()
                local Players = game:GetService("Players")
                local player = Players.LocalPlayer
                while autoCollectEnabled do
                    local character = player.Character or player.CharacterAdded:Wait()
                    local hrp = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart")
                    local drops = workspace:FindFirstChild("__DROPS__") or workspace:WaitForChild("__DROPS__")
                    for _, drop in ipairs(drops:GetChildren()) do
                        if drop:IsA("BasePart") then
                            drop.CFrame = hrp.CFrame
                        end
                    end
                    task.wait(3)
                end
            end)
        else
            if autoCollectCoroutine then
                task.cancel(autoCollectCoroutine)
                autoCollectCoroutine = nil
            end
        end
    end
})


local AutoFightSection = Tabs.AutoFarm:AddSection("OP Auto Fight")

-- Function to extract world and boss number from key
local function getWorldAndBossNumber(key)
    local world, boss = string.match(tostring(key), "World(%d+)Boss(%d+)")
    if world and boss then
        return world, boss
    else
        return nil, nil
    end
end

-- Load bosses directly from the enum
local success, BossesEnum = pcall(function()
    return require(game:GetService("ReplicatedStorage").Shared.Enums.Bosses)
end)

local bossNames = {}
local bossKeyMap = {}

if success and BossesEnum then
    for bossName, bossValue in pairs(BossesEnum) do
        table.insert(bossNames, bossName)
        bossKeyMap[bossName] = bossValue
    end
    
    -- Sort the boss names
    table.sort(bossNames, function(a, b)
        local aWorld, aBoss = string.match(a, "World(%d+)Boss(%d+)")
        local bWorld, bBoss = string.match(b, "World(%d+)Boss(%d+)")
        aWorld, aBoss = tonumber(aWorld), tonumber(aBoss)
        bWorld, bBoss = tonumber(bWorld), tonumber(bBoss)
        if aWorld == bWorld then
            return aBoss < bBoss
        end
        return aWorld < bWorld
    end)
else
end

local BossDropdown = AutoFightSection:AddDropdown("BossSelect", {
    Title = "Select Boss",
    Description = "Choose a boss to auto fight.",
    Values = bossNames,
    Multi = false,
    Searchable = true,
    Default = bossNames[1] or nil,
    Callback = function(selectedBoss)
        local key = bossKeyMap[selectedBoss]
        if key then
            local worldNum, bossNum = getWorldAndBossNumber(key)
            if worldNum and bossNum then
                -- Handle boss selection
            end
        end
    end
})


local toggleEnabled = false

    local AutoFightToggle = AutoFightSection:AddToggle("AutoFightToggle", {
        Title = "Auto Fight",
        Description = "Automatically fights the selected boss repeatedly.",
        Default = false,
        Callback = function(enabled)
            toggleEnabled = enabled  -- Track toggle state globally

            local ReplicatedStorage = game:GetService("ReplicatedStorage")
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer

            local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
            local autoFightModule = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Normal.Battling.BattleAutoFightController)
            local battleNpcController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Normal.Battling.BattleNpcController)
            local AttackService = ReplicatedStorage.Shared.Packages.Knit.Services.BattleAttackService

            local selectedBoss = BossDropdown.Value
            local bossKey = bossKeyMap[selectedBoss]
            local worldNum, bossNum = getWorldAndBossNumber(bossKey)
            local worldName = "World" .. tostring(worldNum)
            local isFighting = false

            local function startBattle()
                if worldName and bossNum and not isFighting then
                    isFighting = true
                    local args = {
                        [1] = worldName,
                        [2] = tonumber(bossNum)
                    }

                    local success, err = pcall(function()
                        ReplicatedStorage.Shared.Packages.Knit.Services.BattleService.RF.startPvE:InvokeServer(unpack(args))
                    end)

                    if not success then
                        isFighting = false
                    end
                end
            end

            local function attackBoss(bossId, npc)
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("HumanoidRootPart") and npc and npc:FindFirstChild("HumanoidRootPart") then
                    character.HumanoidRootPart.CFrame = CFrame.new(npc.HumanoidRootPart.Position + Vector3.new(5, 0, 0))
                    local args = {
                        [1] = {
                            [1] = tostring(bossId)
                        }
                    }
                    pcall(function()
                        AttackService.RF.attack:InvokeServer(unpack(args))
                    end)
                end
            end

            if toggleEnabled then
                autoFightModule:KnitStart()

                -- Start the first battle
                startBattle()

                -- Replace onSpawnBosses
                if not battleNpcController._originalOnSpawnBosses then
                    battleNpcController._originalOnSpawnBosses = battleNpcController.onSpawnBosses
                end

                battleNpcController.onSpawnBosses = function(self, ...)
                    local originalBosses = {}
                    for k, v in pairs(self.Bosses) do
                        originalBosses[k] = v
                    end

                    local result = battleNpcController._originalOnSpawnBosses(self, ...)

                    for bossId, bossData in pairs(self.Bosses) do
                        if not originalBosses[bossId] and bossData.NPC then
                            attackBoss(bossId, bossData.NPC)
                        end
                    end

                    return result
                end

                -- Connect to onBattleEnded to restart fight
                local BattleService = Knit.GetService("BattleService")
                if BattleService and BattleService.onBattleEnded then
                    BattleService.onBattleEnded:Connect(function(...)
                        isFighting = false
                        if toggleEnabled then
                            task.delay(0.5, function()
                                if toggleEnabled then
                                    startBattle()
                                end
                            end)
                        end
                    end)
                else
                end

                -- Loop to attack closest boss every 0.2 seconds
                task.spawn(function()
                    while toggleEnabled do
                        local character = LocalPlayer.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local hrp = character.HumanoidRootPart
                            local closestBossId, closestBossNpc
                            local shortestDist = math.huge

                            for bossId, bossData in pairs(battleNpcController.Bosses) do
                                local npc = bossData.NPC
                                if npc and npc:FindFirstChild("HumanoidRootPart") then
                                    local dist = (hrp.Position - npc.HumanoidRootPart.Position).Magnitude
                                    if dist < shortestDist then
                                        shortestDist = dist
                                        closestBossId = bossId
                                        closestBossNpc = npc
                                    end
                                end
                            end

                            if closestBossId and closestBossNpc then
                                attackBoss(closestBossId, closestBossNpc)
                            end
                        end

                        task.wait(0.2)
                    end
                end)
            else
                isFighting = false

                -- Restore original spawn boss handler
                if battleNpcController._originalOnSpawnBosses then
                    battleNpcController.onSpawnBosses = battleNpcController._originalOnSpawnBosses
                end
            end
        end
    })


AutoFightSection:AddButton({
    Title = "Never Lose",
    Description = "You will no longer take damage from bosses (rejoining resets this).",
    Callback = function()
        if getgenv().NamecallBlocked then
            return
        end
        getgenv().NamecallBlocked = true

        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local attackRemote = ReplicatedStorage.Shared.Packages.Knit.Services.BattleAttackService.RF.attackPlayer

        local mt = getrawmetatable(game)
        setreadonly(mt, false)

        local oldNamecall = mt.__namecall

        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            if self == attackRemote and method == "InvokeServer" then
                return nil
            end
           return oldNamecall(self, ...)
        end)

        setreadonly(mt, true)

    end
})

local AutoFightSection1 = Tabs.AutoFarm:AddSection("Glitch Fix (Respawn)")

AutoFightSection1:AddButton({
    Title = "Respawn",
    Description = "Sometimes the player can't move after turning off this toggle. This should fix it.",
    Callback = function()
        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        if LocalPlayer and LocalPlayer.Character then
            LocalPlayer.Character:BreakJoints()
        end
    end
})

local EggsSection = Tabs.Eggs:AddSection("Eggs")

local noteegg = Tabs.Eggs:AddParagraph("Note", {
    Title = "Note",
    Content = "For the eggs/sword chests, W = World, and Z = Zone.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local success, EggTypes = pcall(function()
    return require(game:GetService("ReplicatedStorage").Shared.Enums.EggTypes)
end)

if not success then
    return
end

-- Collect and parse matching entries for EGGS
local eggEntries = {}

for key, value in pairs(EggTypes) do
    if type(value) == "string" then
        local w, z = string.match(value, "^W(%d+)_Z(%d+)")
        if w and z then
            table.insert(eggEntries, {
                key = key,
                value = value,
                w = tonumber(w),
                z = tonumber(z)
            })
        end
    end
end

-- Sort by world and zone (with nil checks)
table.sort(eggEntries, function(a, b)
    -- Check for nil values first
    if not a and not b then return false end  -- Both nil, consider equal
    if not a then return true end   -- a is nil, b is not; a comes first
    if not b then return false end  -- b is nil, a is not; b comes first

    -- Now check for w and z
    if not a.w and not b.w then return false end
    if not a.w then return true end
    if not b.w then return false end

    if not a.z and not b.z then return false end
    if not a.z then return true end
    if not b.z then return false end

    if a.w == b.w then
        return a.z < b.z
    else
        return a.w < b.w
    end
end)

-- Build dropdown values (egg names)
local eggNames = {}
for _, entry in ipairs(eggEntries) do
    table.insert(eggNames, entry.key)
end

-- Ensure we have at least one egg
if #eggNames == 0 then
    return
end

local SelectedEgg = nil -- Store the actual enum value
local hatchAmount = 1
local autoBuyEnabled = false

local EggDropdown = EggsSection:AddDropdown("EggSelect", {
    Title = "Select Egg",
    Values = eggNames,
    Multi = false,
    Searchable = true,
    Default = eggNames[1],
    Callback = function(value)
        -- Find the corresponding enum value
        for _, entry in ipairs(eggEntries) do
            if entry.key == value then
                SelectedEgg = entry.value
                break
            end
        end
    end
})

-- Set initial selected egg value
if eggNames[1] then
    for _, entry in ipairs(eggEntries) do
        if entry.key == eggNames[1] then
            SelectedEgg = entry.value
            break
        end
    end
end

local HatchAmountInput = EggsSection:AddInput("HatchAmountInput", {
    Title = "Hatch Amount",
    Description = "Enter the number of eggs to hatch\n(must own).",
    Placeholder = "1",
    Numeric = true,
    Default = "1",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            hatchAmount = math.floor(num)
        else
            hatchAmount = 1
        end
    end
})

local autoBuyCoroutine = nil

local AutoBuyEggToggle = EggsSection:AddToggle("AutoBuyEggToggle", {
    Title = "Auto Buy Egg",
    Description = "Automatically buys the selected egg with the specified hatch amount.",
    Default = false,
    Callback = function(enabled)
        autoBuyEnabled = enabled

        if enabled then
            autoBuyCoroutine = task.spawn(function()
                while autoBuyEnabled do
                    if SelectedEgg and hatchAmount > 0 then
                        local success, err = pcall(function()
                            local args = {
                                [1] = SelectedEgg,
                                [2] = hatchAmount,
                                [3] = false
                            }

                            local EggService = game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.EggService.RF.purchaseEgg
                            EggService:InvokeServer(unpack(args))
                        end)

                        if not success then
                        end
                    end
                    task.wait(0.1)
                end
            end)
        else
            if autoBuyCoroutine then
                task.cancel(autoBuyCoroutine)
                autoBuyCoroutine = nil
            end
        end
    end
})


-- Sword Chests Section
local ChestSection = Tabs.Eggs:AddSection("Sword Chests")

-- Build chest dropdown values using your robust parsing logic
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local success, EggTypes = pcall(function()
    return require(game:GetService("ReplicatedStorage").Shared.Enums.EggTypes)
end)

if not success then
    return
end

local eggEntries = {}

for key, value in pairs(EggTypes) do
    if type(value) == "string" then
        local w, z = string.match(value, "^W(%d+)_Z(%d+)")
        if w and z then
            local wNum = tonumber(w)
            local zNum = tonumber(z)
            if wNum and zNum then
                table.insert(eggEntries, {
                    key = key,
                    value = value,
                    w = wNum,
                    z = zNum
                })
            end
        end
    end
end

table.sort(eggEntries, function(a, b)
    if not a and not b then return false end
    if not a then return true end
    if not b then return false end
    if not a.w and not b.w then return false end
    if not a.w then return true end
    if not b.w then return false end
    if not a.z and not b.z then return false end
    if not a.z then return true end
    if not b.z then return false end
    if a.w == b.w then
        return a.z < b.z
    else
        return a.w < b.w
    end
end)

local chestNames = {}
for i, entry in ipairs(eggEntries) do
    if entry and entry.key then
        if type(entry.key) == "string" then
            local formattedName = string.gsub(entry.key, "_", "")
            if type(formattedName) == "string" then
                table.insert(chestNames, formattedName)
            end
        end
    end
end


local ChestDropdown = ChestSection:AddDropdown("SelectChestDropdown", {
    Title = "Select Chest",
    Description = "Choose a sword chest.",
    Values = chestNames,
    Multi = false,
    Default = chestNames[1] or nil,
    Callback = function(value)
    end
})

local autoOpenEnabled = false
local autoOpenCoroutine = nil

local AutoOpenChestToggle = ChestSection:AddToggle("AutoOpenChestToggle", {
    Title = "Auto Open",
    Description = "Automatically opens the selected sword chest.",
    Default = false,
    Callback = function(enabled)
        autoOpenEnabled = enabled
        
        if enabled then
            autoOpenCoroutine = task.spawn(function()
                while autoOpenEnabled do
                    local CrateArg = ChestDropdown.Value
                    if CrateArg then
                        -- Remove spaces if any, just in case
                        local crateArg = tostring(CrateArg)
                        local args = {
                            [1] = crateArg
                        }
                        local SwordCrateService = game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.SwordCrateService

                        if SwordCrateService and SwordCrateService.RF and SwordCrateService.RF.open then
                            local success, result = pcall(function()
                                SwordCrateService.RF.open:InvokeServer(unpack(args))
                            end)
                        end
                    end
                    task.wait(1)
                end
            end)
        else
            if autoOpenCoroutine then
                task.cancel(autoOpenCoroutine)
                autoOpenCoroutine = nil
            end
        end
    end
})

local UpgradesSection = Tabs.Upgrades:AddSection("Stats")

local statsInfo = UpgradesSection:AddParagraph("UpgradeStats", {
    Title = "Upgrade Statistics",
    Content = "Loading...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Function to update stats
local function updateStats()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Knit = require(game:GetService("ReplicatedStorage").Shared.Packages.Knit)

    local DataController = Knit.GetController("DataController")
    local ownedUpgrades = DataController:GetValue({"UpgradeTree"})
    local currentPoints = DataController:GetValue({"UpgradePoints"}) or 0
    
    -- Get the upgrade tree data
    local UpgradeTree = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.UpgradeTree)
    
    -- Count total upgrades and calculate total cost
    local totalUpgrades = 0
    local totalCost = 0
    local ownedLookup = {}
    
    -- Create lookup table for owned upgrades
    for _, id in pairs(ownedUpgrades) do
        ownedLookup[id] = true
    end
    
    -- Count total upgrades and calculate cost of missing ones
    for _, upgrade in pairs(UpgradeTree) do
        if type(upgrade) == "table" and not upgrade.Back then
            totalUpgrades += 1
            if not ownedLookup[upgrade.ID] then
                local cost = (type(upgrade.Cost) == "table" and upgrade.Cost.Amount) or 0
                totalCost += cost
            end
        end
    end
    
    local ownedCount = #ownedUpgrades
    local missingCount = totalUpgrades - ownedCount
    
    -- Update the paragraph
    statsInfo:SetValue(string.format(
        "\nCurrent Upgrade Points: %d\n\nOwned Upgrades: %d\nMissing Upgrades: %d\nTotal Upgrades: %d\n\nTotal Cost for Missing Upgrades: %d",
        currentPoints,
        ownedCount,
        missingCount,
        totalUpgrades,
        totalCost
    ))
end

-- Initial update
updateStats()

-- Update every 5 seconds
task.spawn(function()
    while true do
        task.wait(5)
        updateStats()
    end
end)

local UpgradeTreeService = game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.UpgradeTreeService

local autoBuyUpgradesEnabled = false
local autoBuyUpgradesCoroutine = nil

UpgradesSection:AddToggle("AutoBuyUpgrades", {
    Title = "Auto Buy Upgrades",
    Description = "Automatically buy affordable upgrades.",
    Default = false,
    Callback = function(enabled)
        autoBuyUpgradesEnabled = enabled

        if enabled then
            autoBuyUpgradesCoroutine = task.spawn(function()
                while autoBuyUpgradesEnabled do
                    local ReplicatedStorage = game:GetService("ReplicatedStorage")
                    local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
                    local DataController = Knit.GetController("DataController")
                    local ownedUpgrades = DataController:GetValue({"UpgradeTree"})
                    local currentPoints = DataController:GetValue({"UpgradePoints"}) or 0
                    local UpgradeTree = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.UpgradeTree)

                    -- Build lookup for owned upgrades
                    local ownedLookup = {}
                    for _, id in pairs(ownedUpgrades) do
                        ownedLookup[id] = true
                    end

                    local boughtAny = false

                    for _, upgrade in pairs(UpgradeTree) do
                        if type(upgrade) == "table" and not upgrade.Back and not ownedLookup[upgrade.ID] then
                            local cost = (type(upgrade.Cost) == "table" and upgrade.Cost.Amount) or 0
                            if currentPoints >= cost and cost > 0 then
                                local args = { upgrade.ID }
                                pcall(function()
                                    UpgradeTreeService.RF.unlock:InvokeServer(unpack(args))
                                end)
                                boughtAny = true
                                task.wait(1) -- Wait 1 second after buying
                                break -- Only buy one per second
                            end
                        end
                    end

                    if not boughtAny then
                        task.wait(3) -- Wait 3 seconds if nothing affordable
                    end
                end
            end)
        else
            if autoBuyUpgradesCoroutine then
                task.cancel(autoBuyUpgradesCoroutine)
                autoBuyUpgradesCoroutine = nil
            end
        end
    end
})
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local QuestsFolder = game:GetService("ReplicatedStorage").Shared.Data.Core.Quests
local QuestController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Shared.Core.QuestController)

-- Get all quest titles and IDs and sort them alphabetically
local questTitles = {}
local questMap = {}
local moduleInfo = {}

-- First get all module info by ID
for _, questModule in pairs(QuestsFolder:GetChildren()) do
    local quest = require(questModule)
    local success, title = pcall(function() return quest:GetTitle() end)
    if success and title then
        moduleInfo[quest.ID] = {
            title = title,
            module = questModule.Name,
            event = quest.Event,
            id = quest.ID
        }
        table.insert(questTitles, title)
        questMap[title] = quest.ID
    end
end
table.sort(questTitles)

-- Function to check if a quest is active and get its data
local function getQuestData(questId)
    for activeId, activeQuest in pairs(QuestController.Current) do
        if activeQuest.Name and activeQuest.Type == questId then
            return activeQuest
        end
    end
    return nil
end

-- Add the section to Upgrades tab
local QuestSection = Tabs.Upgrades:AddSection("Auto Quest")

local QuestNote = QuestSection:AddParagraph("QuestNote", {
    Title = "Note",
    Content = "Quests that involve hatching, breaking, bosses, etc, will use your selected values from other dropdowns. If the quest requires you to gold pets, this will hatch the selected egg and gold the EASY pets from it.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Variable to store selected quests
local selectedQuests = {}

-- Create dropdown for quest selection
local QuestDropdown = QuestSection:AddDropdown("QuestSelect", {
    Title = "Select Quest",
    Description = "Choose which quest to auto-complete",
    Values = questTitles,
    Multi = true,
    Searchable = true,
    Default = {},
    Callback = function(value)
        selectedQuests = value or {}
    end
})

-- Add Select All button
QuestSection:AddButton({
    Title = "Select All",
    Description = "Select all available quests",
    Callback = function()
        local allSelected = {}
        for _, title in ipairs(questTitles) do
            allSelected[title] = true
        end
        QuestDropdown:SetValue(allSelected)
    end
})


local EggsModule = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.Eggs)
local PetsEnum = require(game:GetService("ReplicatedStorage").Shared.Enums.Pets)

local function completeQuest(questName, questData)
    if not questData or questData.Completed then return end

    -- For Swing Sword quest
    if questName == "Swing Sword" then
        task.spawn(function()
            while autoCompleteEnabled and not questData.Completed do
                game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.SwordAttackService.RF.swing:InvokeServer()
                task.wait(0.25)
            end
        end)
    end

    if questName == "Upgrade Pets" then
        task.spawn(function()
            while autoCompleteEnabled and not questData.Completed do
                -- Find the egg in EggsModule that matches our ID
                local egg = EggsModule.Eggs[SelectedEgg]
                if egg and egg.Loot and egg.Loot.Rewards then
                    -- Collect all common pets from this egg
                    local commonPets = {}
                    
                    -- First get all pets with >15% chance and their IDs
                    for petId, chance in pairs(egg.Loot.Rewards) do
                        if type(petId) ~= "string" and chance > 15 then
                            -- Find the pet's name from PetsEnum
                            for petName, enumId in pairs(PetsEnum) do
                                if enumId == petId then
                                    table.insert(commonPets, {
                                        id = tostring(enumId) .. "-1",  -- Add the -1 for tier 1
                                        chance = chance
                                    })
                                    break
                                end
                            end
                        end
                    end
    
                    -- Keep hatching eggs while quest isn't complete
                    local args = {
                        [1] = SelectedEgg,
                        [2] = hatchAmount,
                        [3] = false
                    }
                    game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
    
                    -- If we found any common pets, try to gold a random one
                    if #commonPets > 0 then
                        -- Pick a random pet from our common pets
                        local randomPet = commonPets[math.random(1, #commonPets)]
                        
                        -- Try to gold this pet using its ID
                        local args = {
                            [1] = randomPet.id,  -- Use the ID-1 format directly
                            [2] = 5
                        }
                        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.GoldMachineService.RF.craft:InvokeServer(unpack(args))
                    end
                end
                task.wait(1)
            end
        end)
    end

    if questName == "Kill Bosses" or questName == "Win Battles" then
        task.spawn(function()
            -- Remember if AutoFight was already on before quest automation
            local wasOn = AutoFightToggle.Value

            while autoCompleteEnabled and not questData.Completed do
                -- Enable auto fight if it's not already on
                if not AutoFightToggle.Value then
                    AutoFightToggle:SetValue(true)
                end

                -- Stop when quest is complete
                if questData.Progress >= questData.Goal then
                    -- Only turn it off if we turned it on
                    if not wasOn then
                        AutoFightToggle:SetValue(false)
                    end
                    break
                end

                task.wait(1)
            end
        end)
    end


    -- For Open Sword Chest quest
    if questName == "Open Sword Chests" then
        task.spawn(function()
            while autoCompleteEnabled and not questData.Completed do
                local args = {
                    [1] = ChestDropdown.Value or "W1Z1"
                }
                game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.SwordCrateService.RF.open:InvokeServer(unpack(args))
                task.wait(1)
            end
        end)
    end 

    -- For Hatch Eggs quest
    if questName == "Hatch Eggs" then
        task.spawn(function()
            while autoCompleteEnabled and not questData.Completed do
                
                local args = {
                    [1] = SelectedEgg or "W1_Z1", -- Use the selected egg or default
                    [2] = hatchAmount or 1,
                    [3] = false
                }
                
                game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.EggService.RF.purchaseEgg:InvokeServer(unpack(args))
                task.wait(1)
            end
        end)
    end

    -- For Open Gifts quest
    if questName == "Open Gifts" then
        task.spawn(function()
            while autoCompleteEnabled and not questData.Completed do
                -- Load BackpackInventoryController
                local BackpackInventoryController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Shared.Utility.Backpack.BackpackInventoryController)


                -- Access the GiftConsumables category (corrected from 'Gift' to 'GiftConsumables')
                local giftCategory = BackpackInventoryController.Amounts.GiftConsumables or {}

                local maxAmount = 0
                local bestGiftBag = nil

                -- Iterate over giftCategory to find the bag with the most gifts
                for itemName, data in pairs(giftCategory) do
                    if type(data) == "table" then
                        -- Nested table found, iterate inside it
                        for nestedName, nestedAmount in pairs(data) do
                            if nestedAmount > maxAmount then
                                maxAmount = nestedAmount
                                bestGiftBag = nestedName
                            end
                        end
                    else
                        if data > maxAmount then
                            maxAmount = data
                            bestGiftBag = itemName
                        end
                    end
                end

                if bestGiftBag then
                    local giftsToOpen = questData.Goal - questData.Progress

                    if giftsToOpen > 0 and maxAmount > 0 then
                        local args = {bestGiftBag, giftsToOpen}
                        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.GiftBagService.RF.openGift:InvokeServer(unpack(args))
                    else
                    end
                end

                task.wait(1)
            end
        end)
    end
end




-- Update the auto-complete toggle callback
QuestSection:AddToggle("AutoCompleteQuest", {
    Title = "Auto Complete Quest",
    Description = "Automatically complete selected quests",
    Default = false,
    Callback = function(enabled)
        autoCompleteEnabled = enabled
        
        if enabled then
            task.spawn(function()
                while autoCompleteEnabled do
                    for title, isSelected in pairs(selectedQuests) do
                        if isSelected then
                            local questId = questMap[title]
                            local questData = getQuestData(questId)
                            if questData and not questData.Completed then
                                completeQuest(title, questData)
                            end
                        end
                    end
                    task.wait(1)
                end
            end)
        end
    end
})
-- Add a paragraph to show current quest progress
local questInfoParagraph = QuestSection:AddParagraph("QuestInfo", {
    Title = "Selected Quests Progress",
    Content = "Select quests to see progress",
})

-- Update quest progress every 5 seconds
task.spawn(function()
    while true do
        local progressText = ""
        local progressEntries = {}
        
        for title, isSelected in pairs(selectedQuests) do
            if isSelected then
                local questId = questMap[title]
                local questData = getQuestData(questId)
                
                if questData then
                    table.insert(progressEntries, {
                        title = title,
                        text = string.format(
                            "%s: %d/%d (Active Quest)",
                            title,
                            questData.Progress or 0,
                            questData.Goal or 0,
                            tostring(questData.Completed)
                        )
                    })
                else
                    table.insert(progressEntries, {
                        title = title,
                        text = title .. " (Not Currently Active)"
                    })
                end
            end
        end
        
        table.sort(progressEntries, function(a, b) return a.title < b.title end)
        
        for _, entry in ipairs(progressEntries) do
            progressText = progressText .. entry.text .. "\n"
        end
        
        questInfoParagraph:SetValue(progressText ~= "" and progressText or "No quests selected")
        task.wait(5)
    end
end)

local TeleportSection = Tabs.Teleport:AddSection("Breakable Spawns")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local breakables = workspace:WaitForChild("Core_Game"):WaitForChild("Breakables")

-- ...existing code...
local function addSpawnButtons(parent, prefix)
    prefix = prefix or ""
    for _, child in pairs(parent:GetChildren()) do
        local path = prefix .. child.Name
        if child.Name == "Spawn" then
            -- Parse World and Zone from the path
            local world, zone = string.match(path, "World(%d+)%.(%d+)%.Spawn")
            local buttonTitle
            if world and zone then
                buttonTitle = "World " .. world .. " Zone " .. zone
            else
                buttonTitle = path
            end
            TeleportSection:AddButton({
                Title = buttonTitle,
                Description = "Teleport to " .. buttonTitle,
                Callback = function()
                    if LocalPlayer and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(child.Position)
                    end
                end
            })
        end
        if #child:GetChildren() > 0 then
            addSpawnButtons(child, path .. ".")
        end
    end
end

addSpawnButtons(breakables)

local MachinesSection = Tabs.Machines:AddSection("Gold Machine")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Shared.Packages.Knit)

local ItemTiersEnum = require(game:GetService("ReplicatedStorage").Shared.Enums.ItemTiers)
local TierNames = {}
for name, number in pairs(ItemTiersEnum) do
    TierNames[number] = name
end

local function collectUnlockedTier1PetsFromGui()
    local petController = Knit.GetController("PetController")
    local petDataStore = petController.Pets
    local playerGui = Players.LocalPlayer.PlayerGui
    local inventory = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.MainFrames.Inventory.Inner.Holder.Inner.Pages.Pets.Contents.Contents.Inventory
    local equippedInventory = game:GetService("Players").LocalPlayer.PlayerGui.GameUI.MainFrames.Inventory.Inner.Holder.Inner.Pages.Pets.Contents.Contents.Equipped_Inventory

    local pets = {}
    local seenNames = {}

    local function collect(folder)
        for _, child in pairs(folder:GetChildren()) do
            if child:IsA("ImageButton") then
                local id = child:GetAttribute("ID")
                local tier = child:GetAttribute("Tier")
                if id and tier and tonumber(tier) == 1 then
                    local tierName = TierNames[tier] or "Unknown"
                    local fullKey = id .. "-" .. tier
                    local petData = petDataStore[fullKey]
                    if petData and petData.L == false then
                        local guiName = string.match(child.Name, "^nil%-(.-)%-.+%-.+") or "Unknown"
                        local fullName = (tierName ~= "Normal" and tierName .. " " or "") .. guiName
                        if not seenNames[fullName] then
                            seenNames[fullName] = true
                            table.insert(pets, {
                                Name = fullName,
                                Quantity = petData.Q or 0,
                                ID = id,
                                Tier = tonumber(tier),
                            })
                        end
                    end
                end
            end
        end
    end

    collect(inventory)
    collect(equippedInventory)
    return pets
end

-- Store reference to current pets data
local unlockedTier1Pets = collectUnlockedTier1PetsFromGui()

local function getPetNames()
    local petNames = {}
    local nameSet = {}
    for _, pet in ipairs(unlockedTier1Pets) do
        if not nameSet[pet.Name] then
            table.insert(petNames, pet.Name)
            nameSet[pet.Name] = true
        end
    end
    return petNames
end

local petInfoParagraph = MachinesSection:AddParagraph("PetInfo", {
    Title = "Pet Info",
    Content = "Selected Pets",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Function to update pet info display
local function updatePetInfoDisplay(selectedNamesDict, previousSelection)
    -- Refresh pet data to get current quantities
    unlockedTier1Pets = collectUnlockedTier1PetsFromGui()
    
    local lines = {}
    local nameSet = {}
    
    for selectedName, isSelected in pairs(selectedNamesDict) do
        if isSelected and not nameSet[selectedName] then
            for _, pet in ipairs(unlockedTier1Pets) do
                if pet.Name == selectedName then
                    table.insert(lines, string.format("%s - %dx", pet.Name, pet.Quantity))
                    

                    if not previousSelection or not previousSelection[selectedName] then
                    end
                    
                    nameSet[selectedName] = true
                    break
                end
            end
        end
    end
    petInfoParagraph:SetValue(#lines > 0 and table.concat(lines, "\n") or "Select pets to see their name and quantity.")
end

-- Store previous selection to track changes
local previousSelection = {}

local petDropdown = MachinesSection:AddDropdown("UnlockedTier1PetsDropdown", {
    Title = "Select Pets to turn Golden",
    Description = "Select unlocked pets.",
    Values = getPetNames(),
    Multi = true,
    Default = {},
    Callback = function(selectedNamesDict)
        updatePetInfoDisplay(selectedNamesDict, previousSelection)
        -- Update previous selection for next comparison
        previousSelection = {}
        for name, isSelected in pairs(selectedNamesDict) do
            previousSelection[name] = isSelected
        end
    end
})

-- Button to refresh pet list
MachinesSection:AddButton({
    Title = "Refresh Pet List",
    Description = "Update the list of available pets",
    Callback = function()
        -- Refresh the pets data
        unlockedTier1Pets = collectUnlockedTier1PetsFromGui()
        
        -- Get updated pet names
        local updatedPetNames = getPetNames()
        
        -- Update the dropdown values
        petDropdown:SetValues(updatedPetNames)
        
        -- Update the display with current selection
        local currentSelection = petDropdown.Value or {}
        updatePetInfoDisplay(currentSelection, previousSelection)
        
        -- Update previous selection after refresh
        previousSelection = {}
        for name, isSelected in pairs(currentSelection) do
            previousSelection[name] = isSelected
        end
    end
})

-- Auto Gold Pets functionality
local autoGoldEnabled = false
local autoGoldConnection = nil

local autoGoldToggle = MachinesSection:AddToggle("AutoGoldPets", {
    Title = "Auto Gold Pets",
    Description = "Automatically gold selected pets (if enough pets are owned).",
    Default = false,
    Callback = function(enabled)
        autoGoldEnabled = enabled
        
        if enabled then           
            -- Start the auto gold loop
            autoGoldConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not autoGoldEnabled then return end
                
                local selectedPets = petDropdown.Value or {}
                
                for petName, isSelected in pairs(selectedPets) do
                    if isSelected then
                        -- Find the pet data
                        for _, pet in ipairs(unlockedTier1Pets) do
                            if pet.Name == petName and pet.Quantity >= 5 then
                                local petId = pet.ID .. "-" .. pet.Tier
                                
                                local args = {
                                    [1] = petId,
                                    [2] = 5
                                }
                                
                                local success, result = pcall(function()
                                    return game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.GoldMachineService.RF.craft:InvokeServer(unpack(args))
                                end)
                                
                                break
                            end
                        end
                    end
                end
                
                wait(1) -- Gold pets every second
            end)
        else
            -- Stop the auto gold loop
            if autoGoldConnection then
                autoGoldConnection:Disconnect()
                autoGoldConnection = nil
            end
        end
    end
})

-- Update pet quantities every 3 seconds
spawn(function()
    while true do
        local currentSelection = petDropdown.Value or {}
        if currentSelection and next(currentSelection) then
            updatePetInfoDisplay(currentSelection, previousSelection)
        end
        wait(3) -- Update every 3 seconds
    end
end)


local Plots = Tabs.Plant:AddSection("Garden Plots")

local isBuying = false

local buyplottoggle = Plots:AddToggle("AutoBuyPlot", {
    Title = "Auto Buy Plot(s)",
    Description = "Automatically buy affordable plots.",
    Default = false,
    Callback = function(enabled)
        isBuying = enabled
        if enabled then
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
                local PlotData = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.Crafting.PlotData)
                local DataController = Knit.GetController("DataController")
                local PlotService = game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PlotService
                local Players = game:GetService("Players")
                local player = Players.LocalPlayer

                while isBuying do
                    -- Get current gems from GUI
                    local success, gems = pcall(function()
                        local textLabel = player.PlayerGui.GameUI.HUDS.Top_Middle.Inner.Currency:GetChildren()[14].TextLabel
                        local text = textLabel.Text
                        return tonumber(text:gsub(",", ""))
                    end)
                    local currentGems = success and gems or 0

                    -- Get purchased plots
                    local purchased = DataController:GetValue({ "GardenPlots", "Purchased" }) or {}
                    local missingPlots = {}
                    for plotName in pairs(PlotData.Plots) do
                        if not purchased[plotName] then
                            table.insert(missingPlots, plotName)
                        end
                    end
                    table.sort(missingPlots)

                    if #missingPlots > 0 then
                        local nextPlotName = missingPlots[1]
                        local nextPlotPrice = PlotData.Prices[#purchased + 1]
                        if currentGems >= nextPlotPrice then
                            pcall(function()
                                PlotService.RF.purchaseSlot:InvokeServer(nextPlotName)
                            end)
                            task.wait(1)
                        else
                            task.wait(5)
                        end
                    else
                        task.wait(5)
                    end
                end
            end)
        end
    end
})

local AutoPlant = Tabs.Plant:AddSection("Auto Plant")

local SeedData = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.Crafting.SeedData)

-- Get all seed names from SeedData
local allSeedNames = {}
for seedName, _ in pairs(SeedData) do
    table.insert(allSeedNames, seedName)
end
table.sort(allSeedNames)

local selectedSeedsToPlant = {}

local autoSeedDropdown = AutoPlant:AddDropdown("SelectSeedsToPlant", {
    Title = "Select Seeds to Plant",
    Description = "These will be planted in available plots.",
    Values = allSeedNames,
    Multi = true,
    Default = {},
    Callback = function(selected)
        selectedSeedsToPlant = {}
        for seedName, isSelected in pairs(selected) do
            if isSelected then
                table.insert(selectedSeedsToPlant, seedName)
            end
        end
    end
})

-- Add Auto Plant toggle
local autoPlantEnabled = false
local autoPlantCoroutine = nil

AutoPlant:AddToggle("AutoPlant", {
    Title = "Auto Plant Seeds",
    Description = "Automatically plant selected seeds in available plots.",
    Default = false,
    Callback = function(enabled)
        autoPlantEnabled = enabled

        if enabled then
            autoPlantCoroutine = task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
                
                while autoPlantEnabled do
                    local DataController = Knit.GetController("DataController")
                    local BackpackCategory = require(game:GetService("ReplicatedStorage").Shared.Enums.BackpackCategory)
                    local backpackController = Knit.GetController("BackpackController")
                    
                    -- Get available seeds
                    local seeds = backpackController:get(BackpackCategory.Seeds)
                    
                    -- Get plant data for all plots
                    local plantsData = DataController:GetValue({ "GardenPlots", "Plants" }) or {}
                    local purchasedPlots = DataController:GetValue({ "GardenPlots", "Purchased" }) or {}
                    
                    -- Find plots with less than 10 plants
                    local availablePlots = {}
                    for plotName, _ in pairs(purchasedPlots) do
                        local plotPlants = plantsData[plotName]
                        local count = 0
                        if type(plotPlants) == "table" then
                            for _, _ in pairs(plotPlants) do
                                count += 1
                            end
                        end
                        if count < 10 then
                            table.insert(availablePlots, {name = plotName, count = count})
                        end
                    end
                    
                    -- Sort plots by plant count (ascending)
                    table.sort(availablePlots, function(a, b)
                        return a.count < b.count
                    end)
                    
                    -- Try to plant selected seeds in available plots
                    local planted = false
                    
                    if #availablePlots > 0 then
                        for _, seedName in ipairs(selectedSeedsToPlant) do
                            if seeds[seedName] and seeds[seedName] > 0 then
                                for _, plot in ipairs(availablePlots) do
                                    
                                    local args = {
                                        [1] = plot.name,
                                        [2] = seedName,
                                        [3] = {
                                            [1] = 1,
                                            [2] = 1
                                        }
                                    }
                                    
                                    pcall(function()
                                        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PlantService.RF.plant:InvokeServer(unpack(args))
                                    end)
                                    
                                    planted = true
                                    task.wait(0.5)
                                    break -- Move to next seed after successful planting
                                end
                            end
                        end
                    end
                    
                    if not planted then
                        task.wait(5) 
                    else
                        task.wait(1) 
                    end
                end
            end)
        else
            if autoPlantCoroutine then
                task.cancel(autoPlantCoroutine)
                autoPlantCoroutine = nil
            end
        end
    end
})


local AutoHarvest = Tabs.Plant:AddSection("Auto Harvest")

local PlotData = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.Crafting.PlotData)

-- Build dropdown values from all plot names
local allPlotNames = {}
for plotName, _ in pairs(PlotData.Plots) do
    table.insert(allPlotNames, plotName)
end
table.sort(allPlotNames)

local selectedPlotsToHarvest = {}

local noteplot = AutoHarvest:AddParagraph("Note", {
    Title = "Note",
    Content = "The plots won't visually show as harvested until you rejoin, but you will still gain the items and continue to be able to plant.",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})
local plotDropdown = AutoHarvest:AddDropdown("SelectPlotsToHarvest", {
    Title = "Select Plots to Auto Harvest",
    Description = "Choose plots to auto harvest (multi-select).",
    Values = allPlotNames,
    Multi = true,
    Default = {},
    Callback = function(selected)
        selectedPlotsToHarvest = selected or {}
    end
})

local autoHarvestEnabled = false
local autoHarvestCoroutine = nil

AutoHarvest:AddToggle("AutoHarvest", {
    Title = "Auto Harvest",
    Description = "Automatically harvests the selected plots.",
    Default = false,
    Callback = function(enabled)
        autoHarvestEnabled = enabled

        if enabled then
            autoHarvestCoroutine = task.spawn(function()
                while autoHarvestEnabled do
                    for plotName, isSelected in pairs(selectedPlotsToHarvest) do
                        if isSelected then
                            local args = { [1] = plotName }
                            pcall(function()
                                game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PlotService.RF.harvest:InvokeServer(unpack(args))
                            end)
                            task.wait(0.5)
                        end
                    end
                    task.wait(2)
                end
            end)
        else
            if autoHarvestCoroutine then
                task.cancel(autoHarvestCoroutine)
                autoHarvestCoroutine = nil
            end
        end
    end
})

-- Auto Buy Seeds Section
local AutoBuySeeds = Tabs.Plant:AddSection("Auto Buy Seeds")

local seedDropdownValues = {}
for seedName, _ in pairs(SeedData) do
    seedDropdownValues[seedName] = seedName
end

local selectedSeedToBuy = nil
local seedPurchaseAmount = 1
local autoBuySeedsEnabled = false
local autoBuySeedsCoroutine = nil

AutoBuySeeds:AddDropdown("SelectSeedToBuy", {
    Title = "Select Seed",
    Description = "Choose which seed to purchase.",
    Values = seedDropdownValues,
    Multi = false,
    Default = next(seedDropdownValues),
    Callback = function(selected)
        selectedSeedToBuy = selected
    end
})

AutoBuySeeds:AddInput("SeedPurchaseAmount", {
    Title = "Purchase Amount",
    Description = "The number of seeds you wish\nto buy.",
    Placeholder = "1",
    Numeric = true,
    Default = "1",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            seedPurchaseAmount = math.floor(num)
        else
            seedPurchaseAmount = 1
        end
    end
})

-- Button to Buy Seeds a Fixed Number of Times
AutoBuySeeds:AddButton({
    Title = "Buy Selected Seeds",
    Description = "Purchases the selected seed the chosen number of times.",
    Callback = function()
        if not selectedSeedToBuy then
            return
        end

        autoBuySeedsEnabled = true -- mark as active

        autoBuySeedsCoroutine = task.spawn(function()
            for i = 1, seedPurchaseAmount do
                if not autoBuySeedsEnabled then
                    break
                end

                pcall(function()
                    game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.SeedStoreService.RF.purchase:InvokeServer(selectedSeedToBuy)
                end)
                task.wait(0.5) -- small delay between purchases
            end

            autoBuySeedsEnabled = false
            autoBuySeedsCoroutine = nil
        end)
    end
})

-- Emergency Stop for Auto Buy Seeds
AutoBuySeeds:AddButton({
    Title = "Emergency Stop Buying",
    Description = "Force stops seed purchases instantly.",
    Callback = function()
        autoBuySeedsEnabled = false
        if autoBuySeedsCoroutine then
            task.cancel(autoBuySeedsCoroutine)
            autoBuySeedsCoroutine = nil
        end
    end
})

-- Potion Crafting Section
local AutoPotionSection = Tabs.Potion:AddSection("Potion Crafting")

-- Get potion data from game
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Shared.Packages.Knit)

-- Wait for Knit to initialize if needed
if not Knit.Started then
    Knit.OnStart():await()
end

local PotionController = Knit.GetController("PotionController")
local UpgradeTreeController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Shared.Core.UpgradeTree.UpgradeTreeController)
local RomanModule = require(ReplicatedStorage.Shared.Vendor.RomanModule)
local Potions = require(ReplicatedStorage.Shared.Balancing.Shared.Items.Potions)
local PotionTypes = require(ReplicatedStorage.Shared.Enums.PotionTypes)
local PotionUpgradeMachine = require(ReplicatedStorage.Shared.Balancing.Shared.Machines.PotionUpgradeMachine)
local UpgradeTreeTypes = require(ReplicatedStorage.Shared.Enums.UpgradeTreeTypes)

-- Check for tier unlocks
local tier3Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node116)
local tier4Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node117)

-- Create mappings between display names, IDs, and enum keys
local displayNameToEnumKey = {}
local enumKeyToDisplayName = {}
local idToEnumKey = {}

-- Build the mapping tables
for enumKey, potionId in pairs(PotionTypes) do
    local potionData = Potions[potionId]
    if potionData and potionData.Name then
        displayNameToEnumKey[potionData.Name] = enumKey
        enumKeyToDisplayName[enumKey] = potionData.Name
        idToEnumKey[potionId] = enumKey
    end
end

-- Format potion name with tier and enum key
local function formatPotionName(potionId, tier, includeEnumKey)
    local potion = Potions[potionId]
    local name = potion and potion.Name or potionId
    local enumKey = idToEnumKey[potionId] or "Unknown"
    
    local tierNum = tonumber(tier) or 1
    local romanTier = RomanModule.NumberToRoman(tierNum)
    
    if includeEnumKey then
        return string.format("%s (%s) %s", enumKey, name, romanTier)
    else
        return string.format("%s %s", name, romanTier)
    end
end

-- Convert Roman numeral to number
local function romanToNumber(roman)
    if roman == "I" then return 1 end
    if roman == "II" then return 2 end
    if roman == "III" then return 3 end
    if roman == "IV" then return 4 end
    if roman == "V" then return 5 end
    if roman == "VI" then return 6 end
    if roman == "VII" then return 7 end
    if roman == "VIII" then return 8 end
    return 1 -- Default fallback
end

-- Get potion ID and tier from dropdown name string
local function getPotionIdFromName(fullName)
    -- Try format: "EnumKey (DisplayName) RomanTier"
    local enumKey, displayName, roman = fullName:match("^([%w_]+)%s+%((.+)%)%s+([IVX]+)$")
    
    if not enumKey then
        -- Try format: "DisplayName RomanTier"
        displayName, roman = fullName:match("(.+) ([IVX]+)$")
        if displayName then
            enumKey = displayNameToEnumKey[displayName]
        end
    end
    
    if not roman or (not enumKey and not displayName) then
        return nil, nil
    end
    
    local tier = romanToNumber(roman)
    
    if enumKey and PotionTypes[enumKey] then
        return PotionTypes[enumKey], tier
    end
    
    if displayName then
        local mappedEnumKey = displayNameToEnumKey[displayName]
        if mappedEnumKey and PotionTypes[mappedEnumKey] then
            return PotionTypes[mappedEnumKey], tier
        end
    end
    
    -- Last resort: search by displayName in Potions
    if displayName then
        for potionId, potionData in pairs(Potions) do
            if potionData.Name == displayName then
                return potionId, tier
            end
        end
    end
    
    return nil, nil
end

-- Create sorted list of potions with their data for dropdown
local function getPotionsList()
    local allPotions = {}
    local storage = PotionController.Storage or {}

    for potionId, tiers in pairs(storage) do
        local displayData = idToEnumKey[potionId] and {
            enumKey = idToEnumKey[potionId],
            realName = Potions[potionId] and Potions[potionId].Name or "Unknown"
        } or { 
            enumKey = tostring(potionId), 
            realName = (Potions[potionId] and Potions[potionId].Name) or "Unknown" 
        }

        for tier, amount in pairs(tiers) do
            if typeof(tier) == "string" then
                tier = tonumber(tier) or tier
            end
            if amount and amount > 0 then
                local name = string.format("%s (%s) %s", 
                    displayData.enumKey,
                    displayData.realName,
                    tonumber(tier) and RomanModule.NumberToRoman(tier) or tostring(tier)
                )
                table.insert(allPotions, {
                    name = name,
                    id = potionId,
                    tier = tier,
                    amount = amount,
                    enumKey = displayData.enumKey,
                    realName = displayData.realName,
                    sortKey = string.lower(displayData.enumKey) .. (tonumber(tier) and string.format("%03d", tier) or tostring(tier))
                })
            end
        end
    end

    table.sort(allPotions, function(a, b)
        if a.enumKey == b.enumKey then
            local aTier = tonumber(a.tier) or 0
            local bTier = tonumber(b.tier) or 0
            return aTier < bTier
        end
        return a.enumKey < b.enumKey
    end)

    return allPotions
end

local function getPotionNames()
    local potions = getPotionsList()
    local names = {}
    for _, potion in ipairs(potions) do
        table.insert(names, potion.name)
    end
    return names
end

local function getMaxCraftable(potionId, tier)
    local storage = PotionController.Storage or {}

    if typeof(tier) == "string" then
        tier = tonumber(tier) or tier
    end

    if not storage[potionId] or not storage[potionId][tier] then
        return 0
    end

    local amount = storage[potionId][tier]

    -- Divide by 4 and round down
    return math.floor(amount / 4)
end

-- Selected potions and craft amount vars
local selectedPotions = {}
local craftAmount = 1

-- Add potion info paragraph
local potionInfoParagraph = AutoPotionSection:AddParagraph("PotionInfo", {
    Title = "Potion Crafting Info",
    Content = "Select potions to see crafting information",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local function updatePotionInfo(selectedPotions)
    if not selectedPotions or not next(selectedPotions) then
        potionInfoParagraph:SetValue("Select potions to see crafting information")
        return
    end

    local infoText = ""

    for potionName, isSelected in pairs(selectedPotions) do
        if isSelected then
            local potionId, tier = getPotionIdFromName(potionName)
            if not potionId then
                infoText = infoText .. "Unable to find data for " .. potionName .. "\n\n"
            else
                local amount = 0
                local storage = PotionController.Storage or {}
                -- Get actual stored amount (check both numeric and string tier keys)
                amount = storage[potionId] and (storage[potionId][tier] or storage[potionId][tostring(tier)]) or 0

                -- Calculate how many potions can be crafted: amount divided by 4, rounded down
                local maxCraftable = math.floor(amount / 4)

                -- Determine if crafting is possible
                local canCraft = maxCraftable >= 1

                -- Check tier unlocks for next tier
                local nextTier = tonumber(tier) and tier + 1 or 2
                local tierUnlocked = true
                if nextTier == 3 and not tier3Unlocked then
                    tierUnlocked = false
                elseif nextTier == 4 and not tier4Unlocked then
                    tierUnlocked = false
                elseif nextTier > 4 then
                    tierUnlocked = false
                end

                -- Build info string
                infoText = infoText .. potionName .. ":\n"
                infoText = infoText .. "• Current amount: " .. amount .. "\n"
                infoText = infoText .. "• Can craft: " .. (canCraft and "Yes" or "No") .. "\n"
                infoText = infoText .. "• Max craftable: " .. maxCraftable .. "\n"
                infoText = infoText .. "• Crafting Tier unlocked: " .. (tierUnlocked and "Yes" or "No (crafting won't work)") .. "\n\n"
            end
        end
    end

    potionInfoParagraph:SetValue(infoText ~= "" and infoText or "No valid potions selected")
end


-- Add potion dropdown (multi-select)
local potionDropdown = AutoPotionSection:AddDropdown("PotionSelect", {
    Title = "Select Potions",
    Description = "Choose which potions to craft (multi-select)",
    Values = getPotionNames(),
    Multi = true,
    Default = {},
    Callback = function(value)
        selectedPotions = value
        updatePotionInfo(value)
    end
})

-- Add craft amount input
local craftAmountInput = AutoPotionSection:AddInput("CraftAmount", {
    Title = "Craft Amount",
    Description = "Number of potions to craft",
    Placeholder = "--",
    Numeric = true,
    Default = "",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            craftAmount = math.floor(num * 4)
        else
            craftAmount = 4
        end
    end
})

-- Craft selected potions button
AutoPotionSection:AddButton({
    Title = "Craft Selected Potions",
    Description = "Craft the selected amount of each selected potion",
    Callback = function()
        if not next(selectedPotions) then return end
        
        for potionName, isSelected in pairs(selectedPotions) do
            if isSelected then
                local potionId, tier = getPotionIdFromName(potionName)
                if potionId and tier then
                    local args = {potionId, tier, craftAmount}
                    pcall(function()
                        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PotionUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                    end)
                    task.wait(0.2)
                end
            end
        end
        
        task.wait(0.5)
        updatePotionInfo(selectedPotions)
    end
})

AutoPotionSection:AddButton{
    Title = "Craft All",
    Description = "Craft all your selected potions.",
    Callback = function()
        if not next(selectedPotions) then return end

        local storage = PotionController.Storage or {}
        local totalCraft = 0
        local potionsToCraft = {}

        for potionName, isSelected in pairs(selectedPotions) do
            if isSelected then
                local potionId, tier = getPotionIdFromName(potionName)
                if potionId and tier then
                    local amount = (storage[potionId] and (storage[potionId][tier] or storage[potionId][tostring(tier)])) or 0
                    if amount > 0 then
                        table.insert(potionsToCraft, {
                            id = potionId,
                            tier = tier,
                            amount = amount,
                            name = potionName
                        })
                        totalCraft += amount
                    end
                end
            end
        end

        if #potionsToCraft == 0 then return end

        -- Show confirmation dialog
        Window:Dialog{
            Title = "Confirm Crafting",
            Content = ("Are you sure you want to craft all of your selected potions?"), 
            Buttons = {
                {
                    Title = "Confirm",
                    Callback = function()
                        for _, potion in ipairs(potionsToCraft) do
                            local args = {potion.id, potion.tier, potion.amount}
                            pcall(function()
                                game:GetService("ReplicatedStorage")
                                    .Shared.Packages.Knit.Services.PotionUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                            end)
                            task.wait(0.2)
                        end
                        task.wait(0.5)
                        updatePotionInfo(selectedPotions)
                    end
                },
                {
                    Title = "Cancel",
                    Callback = function()
                    end
                }
            }
        }
    end
}


-- Active Potions Section
local ActivePotionsSection = Tabs.Potion:AddSection("Active Potions")

-- Active potions paragraph
local activePotionsParagraph = ActivePotionsSection:AddParagraph("ActivePotions", {
    Title = "Current Active Potions",
    Content = "Loading...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Update active potions display (skip if duration <= 0)
local function updateActivePotions()
    local activeList = {}

    if PotionController.Active then
        for potionId, tiers in pairs(PotionController.Active) do
            for tier, duration in pairs(tiers) do
                if typeof(tier) == "string" then
                    tier = tonumber(tier) or tier
                end
                
                if duration and duration > 0 then
                    local displayData = idToEnumKey[potionId] and {
                        enumKey = idToEnumKey[potionId],
                        realName = Potions[potionId] and Potions[potionId].Name or "Unknown"
                    } or {
                        enumKey = tostring(potionId),
                        realName = (Potions[potionId] and Potions[potionId].Name) or "Unknown"
                    }

                    local name = string.format("%s (%s) %s",
                        displayData.enumKey,
                        displayData.realName,
                        tonumber(tier) and RomanModule.NumberToRoman(tier) or tostring(tier)
                    )

                    table.insert(activeList, {
                        name = name,
                        duration = duration,
                        sortKey = string.lower(displayData.enumKey) .. (tonumber(tier) and string.format("%03d", tier) or tostring(tier))
                    })
                end
            end
        end
    end

    table.sort(activeList, function(a, b)
        return a.sortKey < b.sortKey
    end)

    local activeText = ""
    if #activeList == 0 then
        activeText = "No active potions"
    else
        for _, potion in ipairs(activeList) do
            activeText = activeText .. potion.name .. ": " .. math.floor(potion.duration) .. "s remaining\n"
        end
    end

    activePotionsParagraph:SetValue(activeText)
end

-- Initial update
updateActivePotions()

-- Periodically update active potions every 15 seconds
task.spawn(function()
    while true do
        task.wait(15)
        updateActivePotions()
    end
end)


-- Enchantment Crafting Section
local AutoEnchantSection = Tabs.Enchant:AddSection("Enchantment Crafting")

-- Get enchantment data from game
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Knit = require(ReplicatedStorage.Shared.Packages.Knit)

-- Wait for Knit to initialize if needed
if not Knit.Started then
    Knit.OnStart():await()
end

local EnchantmentController = Knit.GetController("EnchantmentController")
local UpgradeTreeController = require(game:GetService("Players").LocalPlayer.PlayerScripts.Client.Controllers.Shared.Core.UpgradeTree.UpgradeTreeController)
local RomanModule = require(ReplicatedStorage.Shared.Vendor.RomanModule)
local Enchantments = require(ReplicatedStorage.Shared.Balancing.Shared.Items.Enchantments)
local EnchantmentTypes = require(ReplicatedStorage.Shared.Enums.EnchantmentTypes)
local UpgradeTreeTypes = require(ReplicatedStorage.Shared.Enums.UpgradeTreeTypes)

-- Check for tier unlocks (similar to potions)
local tier3Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node116) -- Adjust node IDs if needed
local tier4Unlocked = UpgradeTreeController:hasUnlocked(UpgradeTreeTypes.Node117)

-- Create mappings between display names, IDs, and enum keys
local displayNameToEnumKey = {}
local enumKeyToDisplayName = {}
local idToEnumKey = {}

-- Build the mapping tables
for enumKey, enchantId in pairs(EnchantmentTypes) do
    local enchantData = Enchantments[enchantId]
    if enchantData and enchantData.Name then
        displayNameToEnumKey[enchantData.Name] = enumKey
        enumKeyToDisplayName[enumKey] = enchantData.Name
        idToEnumKey[enchantId] = enumKey
    end
end

-- Format enchantment name with tier and enum key
local function formatEnchantName(enchantId, tier, includeEnumKey)
    local enchant = Enchantments[enchantId]
    local name = enchant and enchant.Name or enchantId
    local enumKey = idToEnumKey[enchantId] or "Unknown"
    
    local tierNum = tonumber(tier) or 1
    local romanTier = RomanModule.NumberToRoman(tierNum)
    
    if includeEnumKey then
        return string.format("%s (%s) %s", enumKey, name, romanTier)
    else
        return string.format("%s %s", name, romanTier)
    end
end

-- Convert Roman numeral to number
local function romanToNumber(roman)
    if roman == "I" then return 1 end
    if roman == "II" then return 2 end
    if roman == "III" then return 3 end
    if roman == "IV" then return 4 end
    if roman == "V" then return 5 end
    if roman == "VI" then return 6 end
    if roman == "VII" then return 7 end
    if roman == "VIII" then return 8 end
    return 1 -- Default fallback
end

-- Get enchantment ID and tier from dropdown name string
local function getEnchantIdFromName(fullName)
    -- Try format: "EnumKey (DisplayName) RomanTier"
    local enumKey, displayName, roman = fullName:match("^([%w_]+)%s+%((.+)%)%s+([IVX]+)$")
    
    if not enumKey then
        -- Try format: "DisplayName RomanTier"
        displayName, roman = fullName:match("(.+) ([IVX]+)$")
        if displayName then
            enumKey = displayNameToEnumKey[displayName]
        end
    end
    
    if not roman or (not enumKey and not displayName) then
        return nil, nil
    end
    
    local tier = romanToNumber(roman)
    
    if enumKey and EnchantmentTypes[enumKey] then
        return EnchantmentTypes[enumKey], tier
    end
    
    if displayName then
        local mappedEnumKey = displayNameToEnumKey[displayName]
        if mappedEnumKey and EnchantmentTypes[mappedEnumKey] then
            return EnchantmentTypes[mappedEnumKey], tier
        end
    end
    
    -- Last resort: search by displayName in Enchantments
    if displayName then
        for enchantId, enchantData in pairs(Enchantments) do
            if enchantData.Name == displayName then
                return enchantId, tier
            end
        end
    end
    
    return nil, nil
end

-- Create sorted list of enchantments with their data for dropdown
local function getEnchantmentsList()
    local allEnchantments = {}
    local storage = EnchantmentController.Storage or {}

    for enchantId, tiers in pairs(storage) do
        local displayData = idToEnumKey[enchantId] and {
            enumKey = idToEnumKey[enchantId],
            realName = Enchantments[enchantId] and Enchantments[enchantId].Name or "Unknown"
        } or { 
            enumKey = tostring(enchantId), 
            realName = (Enchantments[enchantId] and Enchantments[enchantId].Name) or "Unknown" 
        }

        for tier, amount in pairs(tiers) do
            if typeof(tier) == "string" then
                tier = tonumber(tier) or tier
            end
            if amount and amount > 0 then
                local name = string.format("%s (%s) %s", 
                    displayData.enumKey,
                    displayData.realName,
                    tonumber(tier) and RomanModule.NumberToRoman(tier) or tostring(tier)
                )
                table.insert(allEnchantments, {
                    name = name,
                    id = enchantId,
                    tier = tier,
                    amount = amount,
                    enumKey = displayData.enumKey,
                    realName = displayData.realName,
                    sortKey = string.lower(displayData.enumKey) .. (tonumber(tier) and string.format("%03d", tier) or tostring(tier))
                })
            end
        end
    end

    table.sort(allEnchantments, function(a, b)
        if a.enumKey == b.enumKey then
            local aTier = tonumber(a.tier) or 0
            local bTier = tonumber(b.tier) or 0
            return aTier < bTier
        end
        return a.enumKey < b.enumKey
    end)

    return allEnchantments
end

local function getEnchantmentNames()
    local enchants = getEnchantmentsList()
    local names = {}
    for _, enchant in ipairs(enchants) do
        table.insert(names, enchant.name)
    end
    return names
end

local function getMaxCraftable(enchantId, tier)
    local storage = EnchantmentController.Storage or {}

    if typeof(tier) == "string" then
        tier = tonumber(tier) or tier
    end

    if not storage[enchantId] or not storage[enchantId][tier] then
        return 0
    end

    local amount = storage[enchantId][tier]

    -- Divide by 5 and round down (assuming same crafting ratio as potions)
    return math.floor(amount / 5)
end

-- Selected enchantments and craft amount vars
local selectedEnchantments = {}
local craftAmount = 1

-- Add enchantment info paragraph
local enchantInfoParagraph = AutoEnchantSection:AddParagraph("EnchantInfo", {
    Title = "Enchantment Crafting Info",
    Content = "Select enchantments to see crafting information",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

local function updateEnchantInfo(selectedEnchantments)
    if not selectedEnchantments or not next(selectedEnchantments) then
        enchantInfoParagraph:SetValue("Select enchantments to see crafting information")
        return
    end

    local infoText = ""

    for enchantName, isSelected in pairs(selectedEnchantments) do
        if isSelected then
            local enchantId, tier = getEnchantIdFromName(enchantName)
            if not enchantId then
                infoText = infoText .. "Unable to find data for " .. enchantName .. "\n\n"
            else
                local amount = 0
                local storage = EnchantmentController.Storage or {}
                -- Get actual stored amount (check both numeric and string tier keys)
                amount = storage[enchantId] and (storage[enchantId][tier] or storage[enchantId][tostring(tier)]) or 0

                -- Calculate how many enchantments can be crafted: amount divided by 4, rounded down
                local maxCraftable = math.floor(amount / 5)

                -- Determine if crafting is possible
                local canCraft = maxCraftable >= 1

                -- Check tier unlocks for next tier
                local nextTier = tonumber(tier) and tier + 1 or 2
                local tierUnlocked = true
                if nextTier == 3 and not tier3Unlocked then
                    tierUnlocked = false
                elseif nextTier == 4 and not tier4Unlocked then
                    tierUnlocked = false
                elseif nextTier > 4 then
                    tierUnlocked = false
                end

                -- Build info string
                infoText = infoText .. enchantName .. ":\n"
                infoText = infoText .. "• Current amount: " .. amount .. "\n"
                infoText = infoText .. "• Can craft: " .. (canCraft and "Yes" or "No") .. "\n"
                infoText = infoText .. "• Max craftable: " .. maxCraftable .. "\n"
                infoText = infoText .. "• Crafting Tier unlocked: " .. (tierUnlocked and "Yes" or "No (crafting won't work)") .. "\n\n"
            end
        end
    end

    enchantInfoParagraph:SetValue(infoText ~= "" and infoText or "No valid enchantments selected")
end

-- Add enchantment dropdown (multi-select)
local enchantDropdown = AutoEnchantSection:AddDropdown("EnchantSelect", {
    Title = "Select Enchantments",
    Description = "Choose which enchantments to craft (multi-select)",
    Values = getEnchantmentNames(),
    Multi = true,
    Default = {},
    Callback = function(value)
        selectedEnchantments = value
        updateEnchantInfo(value)
    end
})

-- Add craft amount input
local craftAmountInput = AutoEnchantSection:AddInput("EnchantCraftAmount", {
    Title = "Craft Amount",
    Description = "Number of enchants to upgrade",
    Placeholder = "--",
    Numeric = true,
    Default = "",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            craftAmount = math.floor(num * 5)
        else
            craftAmount = 5
        end
    end
})

-- Craft selected enchantments button
AutoEnchantSection:AddButton({
    Title = "Craft Selected Enchantments",
    Description = "Craft the selected amount of each selected enchantment",
    Callback = function()
        if not next(selectedEnchantments) then return end
        
        for enchantName, isSelected in pairs(selectedEnchantments) do
            if isSelected then
                local enchantId, tier = getEnchantIdFromName(enchantName)
                if enchantId and tier then
                    local args = {enchantId, tier, craftAmount}
                    pcall(function()
                        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.EnchantmentUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                    end)
                    task.wait(0.2)
                end
            end
        end
        
        task.wait(0.5)
        updateEnchantInfo(selectedEnchantments)
    end
})

-- Craft All button (similar to potions)
AutoEnchantSection:AddButton({
    Title = "Craft All",
    Description = "Craft all your selected enchantments.",
    Callback = function()
        if not next(selectedEnchantments) then return end

        local storage = EnchantmentController.Storage or {}
        local totalCraft = 0
        local enchantsToCraft = {}

        for enchantName, isSelected in pairs(selectedEnchantments) do
            if isSelected then
                local enchantId, tier = getEnchantIdFromName(enchantName)
                if enchantId and tier then
                    local amount = (storage[enchantId] and (storage[enchantId][tier] or storage[enchantId][tostring(tier)])) or 0
                    if amount > 0 then
                        table.insert(enchantsToCraft, {
                            id = enchantId,
                            tier = tier,
                            amount = amount,
                            name = enchantName
                        })
                        totalCraft += amount
                    end
                end
            end
        end

        if #enchantsToCraft == 0 then return end

        -- Show confirmation dialog
        Window:Dialog({
            Title = "Confirm Crafting",
            Content = ("Are you sure you want to craft all of your selected enchantments?"), 
            Buttons = {
                {
                    Title = "Confirm",
                    Callback = function()
                        for _, enchant in ipairs(enchantsToCraft) do
                            local args = {enchant.id, enchant.tier, enchant.amount}
                            pcall(function()
                                game:GetService("ReplicatedStorage")
                                    .Shared.Packages.Knit.Services.EnchantmentUpgradeService.RF.upgrade:InvokeServer(unpack(args))
                            end)
                            task.wait(0.2)
                        end
                        task.wait(0.5)
                        updateEnchantInfo(selectedEnchantments)
                    end
                },
                {
                    Title = "Cancel",
                    Callback = function()
                    end
                }
            }
        })
    end
})

-- Refresh button to update the enchantment list
AutoEnchantSection:AddButton({
    Title = "Refresh Enchantment List",
    Description = "Update the list of available enchantments",
    Callback = function()
        enchantDropdown:SetValues(getEnchantmentNames())
        updateEnchantInfo(selectedEnchantments)
    end
})

local minigameKeys = 0

-- Add a status paragraph to display Minigame Keys
local minigameStatus = Tabs.Minigames:AddParagraph("MinigameKeys", {
    Title = "Minigame Keys",
    Content = "Loading minigame key count...",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Left
})

-- Function to update minigame key count
local function updateMinigameKeyCount()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Knit = require(ReplicatedStorage.Shared.Packages.Knit)
    local BackpackCategory = require(ReplicatedStorage.Shared.Enums.BackpackCategory)
    local BackpackCurrencyTypes = require(ReplicatedStorage.Shared.Enums.BackpackCurrencyTypes)
    
    -- Get BackpackController
    local backpackController = Knit.GetController("BackpackController")
    
    -- Function to get currency amount
    local function getCurrencyAmount(category, currencyType)
        if backpackController and backpackController.get then
            return backpackController:get(category, currencyType) or 0
        end
        return 0
    end
    
    -- Get and display minigame keys
    minigameKeys = getCurrencyAmount(BackpackCategory.BackpackCurrency, BackpackCurrencyTypes.MinigameKey)
    minigameStatus:SetValue("🔑 Minigame Keys: " .. minigameKeys)
end

-- Initial update
updateMinigameKeyCount()

-- Update key count every 5 seconds
task.spawn(function()
    while true do
        task.wait(5)
        updateMinigameKeyCount()
    end
end)


local ObbySection = Tabs.Minigames:AddSection("Parkour Obby")

local autoObbyEnabled = false
local autoObbyConnection = nil

ObbySection:AddToggle("AutoObby", {
    Title = "Auto Complete Obby",
    Description = "Automatically completes the parkour Obby. If you get stuck when you turn this toggle off, respawn.",
    Default = false,
    Callback = function(enabled)
        autoObbyEnabled = enabled

        if enabled and minigameKeys > 0 then
            autoObbyConnection = task.spawn(function()
                while autoObbyEnabled do
                    -- Enter the obby
                    local args = {
                        [1] = "OBBY_W2Z3"
                    }
                    
                    pcall(function()
                        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ObbyService.RF.enter:InvokeServer(unpack(args))
                    end)
                    
                    -- Wait a moment for obby to load
                    task.wait(0.1)
                    
                    -- Teleport to end if path exists
                    local function teleportToEnd()
                        if workspace:FindFirstChild("Obby") and 
                           workspace.Obby:FindFirstChild("OBBY_W2Z3") and 
                           workspace.Obby.OBBY_W2Z3:FindFirstChild("Important") and
                           workspace.Obby.OBBY_W2Z3.Important:FindFirstChild("End") then
                            
                            local character = game.Players.LocalPlayer.Character
                            if character and character:FindFirstChild("HumanoidRootPart") then
                                character.HumanoidRootPart.CFrame = workspace.Obby.OBBY_W2Z3.Important.End.CFrame + Vector3.new(0, 1, 0)
                                return true
                            end
                        end
                        return false
                    end
                    
                    -- Try to teleport, retry a few times if needed
                    local success = teleportToEnd()
                    
                    -- If failed, check again a few times
                    if not success then
                        for i = 1, 2 do
                            task.wait(0.3)
                            if teleportToEnd() then
                                break
                            end
                        end
                    end
                    
                    -- Wait before next attempt
                    task.wait(1)
                end
            end)
        else
            if autoObbyConnection then
                task.cancel(autoObbyConnection)
                autoObbyConnection = nil
            end
        end
    end
})

-- Gifts Tab: Auto Claim Section
local AutoClaimSection = Tabs.Gifts:AddSection("Auto Claim")

local autoClaimEnabled = false
local autoClaimConnection = nil

AutoClaimSection:AddToggle("AutoClaimGifts", {
    Title = "Auto Claim Gifts",
    Description = "Automatically claim availble gifts (won't visually show as claimed until you rejoin).",
    Default = false,
    Callback = function(enabled)
        autoClaimEnabled = enabled

        if enabled then
            autoClaimConnection = task.spawn(function()
                while autoClaimEnabled do
                    for i = 1, 12 do
                        local args = { i }
                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.TimedRewardsService.RF.claim:InvokeServer(unpack(args))
                        end)
                        task.wait(0.5) -- slight delay between claims to avoid flooding
                    end
                    task.wait(20)
                end
            end)
        else
            if autoClaimConnection then
                task.cancel(autoClaimConnection)
                autoClaimConnection = nil
            end
        end
    end
})

AutoClaimSection:AddToggle("AutoDailyDaily", {
    Title = "Auto Claim Daily Rewards",
    Description = "Automatically claim daily rewards (won't visually show as claimed until you rejoin).",
    Default = false,
    Callback = function(enabled)
        AutoDailyEnabled = enabled

        if enabled then
            AutoDailyConnection = task.spawn(function()
                while AutoDailyEnabled do
                    for i = 1, 7 do
                        local args = { i }
                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DailyService.RF.claim:InvokeServer(unpack(args))
                        end)
                        task.wait(1) -- slight delay between claims to avoid flooding
                    end
                    task.wait(30)
                end
            end)
        else
            if AutoDailyConnection then
                task.cancel(AutoDailyConnection)
                AutoDailyConnection = nil
            end
        end
    end
})


local VendingMachines = require(game:GetService("ReplicatedStorage").Shared.Balancing.Shared.VendingMachines)

-- Build vending machine dropdown values and key map
local vendingNames = {}
local vendingKeyMap = {}

for vendingKey, config in pairs(VendingMachines) do
    local world = config.World or "World?"
    local zone = config.Zone or "Zone?"
    local displayName = tostring(world) .. "_Zone" .. tostring(zone)
    table.insert(vendingNames, displayName)
    vendingKeyMap[displayName] = vendingKey
end

-- Sort vendingNames alphabetically
table.sort(vendingNames)

local selectedVending = {} -- Multi-select dictionary

local vending = Tabs.Gifts:AddSection("Vending Machines")

local vendingDropdown = vending:AddDropdown("VendingSelect", {
    Title = "Select Vending Machine",
    Description = "Choose vending machines to auto buy from.",
    Values = vendingNames,
    Multi = true,
    Default = {},
    Callback = function(selected)
        selectedVending = selected or {}
    end
})

local autoBuyEnabled = false
local autoBuyCoroutine = nilw

local vendingToggle = vending:AddToggle("AutoBuyVending", {
    Title = "Auto Buy",
    Description = "Automatically buys from selected vending machines until stock runs out.",
    Default = false,
    Callback = function(enabled)
        autoBuyEnabled = enabled

        if enabled then
            autoBuyCoroutine = task.spawn(function()
                while autoBuyEnabled do
                    for vendingName, isSelected in pairs(selectedVending) do
                        if isSelected then
                        end
                    end

                    for vendingName, isSelected in pairs(selectedVending) do
                        if isSelected and autoBuyEnabled then
                            local vendingKey = vendingKeyMap[vendingName]
                            local config = VendingMachines[vendingKey]
                            local stock = config and config.Stock or 0

                            local purchases = 0
                            while stock > 0 and purchases < 3 and autoBuyEnabled do
                                pcall(function()
                                    ReplicatedStorage.Shared.Packages.Knit.Services.VendingMachineService.RF.purchase:InvokeServer(vendingKey)
                                end)
                                purchases += 1
                                task.wait(1)

                                -- Refresh stock
                                config = VendingMachines[vendingKey]
                                stock = config and config.Stock or 0
                            end
                        end
                    end

                    task.wait(1801) -- Wait 30 minutes and 1 second before next round
                end
            end)
        else
            if autoBuyCoroutine then
                task.cancel(autoBuyCoroutine)
                autoBuyCoroutine = nil
            end
        end
    end
})



-- Hand the library over to our managers
SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes{}



local antiafk = Tabs.Settings:AddSection("Anti AFK")

Tabs.Settings:AddButton({
    Title = "Anti Afk",
    Description = "Never get kicked for being inactive.",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()
    end
})



InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab("Settings")
